<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Weknow.Cypher.Builder</name>
    </assembly>
    <members>
        <member name="T:Weknow.CypherFormat">
            <summary>
            Cypher formatting options
            </summary>
        </member>
        <member name="F:Weknow.CypherFormat.SingleLine">
            <summary>
            A single line of cypher query
            </summary>
        </member>
        <member name="F:Weknow.CypherFormat.MultiLine">
            <summary>
            Multi line of cypher query
            </summary>
        </member>
        <member name="F:Weknow.CypherFormat.MultiLineDense">
            <summary>
            Multi line of cypher query with some density on where and set properties
            </summary>
        </member>
        <member name="T:Weknow.CypherNamingConvention">
            <summary>
            Formatting options
            </summary>
        </member>
        <member name="F:Weknow.CypherNamingConvention.Default">
            <summary>
            The default
            </summary>
        </member>
        <member name="F:Weknow.CypherNamingConvention.SCREAMING_CASE">
            <summary>
            The screaming case
            </summary>
        </member>
        <member name="F:Weknow.CypherNamingConvention.CamelCase">
            <summary>
            The camel case
            </summary>
        </member>
        <member name="F:Weknow.CypherNamingConvention.pacalCase">
            <summary>
            The pacal case
            </summary>
        </member>
        <member name="T:Weknow.CypherPhrase">
            <summary>
            Cypher Phrase
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.None">
            <summary>
            The none
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Dynamic">
            <summary>
            Arbitrary statement (non-structured)
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Match">
            <summary>
            The match
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Create">
            <summary>
            The create
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Merge">
            <summary>
            The merge
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Delete">
            <summary>
            The delete
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Where">
            <summary>
            The where
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.OptionalMatch">
            <summary>
            The optional match
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Remove">
            <summary>
            The remove
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.DetachDelete">
            <summary>
            The detach delete
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Unwind">
            <summary>
            The unwind
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.With">
            <summary>
            The with
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Return">
            <summary>
            The return
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Union">
            <summary>
            The union
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.UnionAll">
            <summary>
            The union all
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Call">
            <summary>
            The call
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.ForEach">
            <summary>
            For each
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.OnCreate">
            <summary>
            The on create
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.OnMatch">
            <summary>
            The on match
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Set">
            <summary>
            The set
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.And">
            <summary>
            The and
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Or">
            <summary>
            The or
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.ReturnDistinct">
            <summary>
            The return distinct
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.OrderBy">
            <summary>
            The order by
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.OrderByDesc">
            <summary>
            The order by desc
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Skip">
            <summary>
            The skip
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Limit">
            <summary>
            The limit
            </summary>
        </member>
        <member name="F:Weknow.CypherPhrase.Count">
            <summary>
            The count
            </summary>
        </member>
        <member name="T:Weknow.SetInstanceBehavior">
            <summary>
            SET's behavior
            </summary>
        </member>
        <member name="F:Weknow.SetInstanceBehavior.Replace">
            <summary>
            Replace all properties of existing entity
            </summary>
        </member>
        <member name="F:Weknow.SetInstanceBehavior.Update">
            <summary>
            Update properties of existing entity
            </summary>
        </member>
        <member name="T:Weknow.ICypherEntitiesMutations">
            <summary>
            Cypher phrases for handling entities collection
            </summary>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateNew(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            CREATE by entity
            </summary>
            <param name="collection">The collection.</param>
            <param name="labels">The labels.</param>
            <param name="variable">The node's variable.
            When the parameter is null, it will be used as the parameter.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateNew("items", new [] {"A", "B"}, "n", "map")
            Results in:
            UNWIND items as map 
            CREATE (n:A:B map)
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateNew(System.String,System.String,System.String,System.String)">
            <summary>
            Create CREATE instance phrase
            </summary>
            <param name="collection">The collection.</param>
            <param name="label">The node's label which will be used for the parameter format (variable_label).</param>
            <param name="variable">The node's variable.
            When the parameter is null, it will be used as the parameter.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateNew("items", "FOO", "n")
            Results in:
            UNWIND items as n 
            CREATE (n:FOO $n) // Create a node with the given properties.
            --------------------------------------------------------------------------
            CreateNew("items", "FOO", "n", "map")
            Results in:
            UNWIND items as map 
            CREATE (n:FOO:DEV $map) // Create a node with the given properties.
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateNew``1(System.String,System.String,System.String)">
            <summary>
            CREATE by entity
            </summary>
            <typeparam name="T">will be used as the node's label. this label will also use for the parameter format (variable_typeof(T).Name).</typeparam>
            <param name="collection">The collection.</param>
            <param name="variable">The node's variable.
            When the parameter is null, it will be used as the parameter.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateNew<Foo>("items", "n")
            Results in:
            UNWIND items as n 
            CREATE (n:FOO n) // Create a node with the given properties.
            --------------------------------------------------------------------------
            CreateNew<Foo>("items", "n", "map")
            Results in:
            UNWIND items as map 
            CREATE (n:FOO map) // Create a node with the given properties.
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateIfNotExists(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            Create if not exists
            </summary>
            <param name="collection">The collection.</param>
            <param name="labels">The labels.</param>
            <param name="matchProperties">The match properties.</param>
            <param name="variable">The node's variable.
            When the parameter is null, it will be used as the parameter.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists("items", new []{"Person", "Dev"}, new[] {"id", "name"}, "p", "map")
            Results in:
            UNWIND items as map 
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateIfNotExists(System.String,System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create if not exists
            </summary>
            <param name="collection">The collection.</param>
            <param name="label">The label.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists("items", "Person", "p", "map", "id", "name")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {id: $map.id, name: $map.name})
            ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateIfNotExists``1(System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create if not exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists<Person>("items", "p", "map", "id", "name")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {id: $map.id, name: $map.name})
            ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateIfNotExists``1(System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Create if not exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <param name="matchPropertyExpression">The match property expression.
            It will take the lambda variable as the expression variable.
            this variable will serve as the parameter when parameter is null.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists<Person>("items", p => p.name, "map")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateOrUpdate(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            Batch Create or update entities.
            For replace use ReplaceOrUpdate
            </summary>
            <param name="collection">Name of the collection.</param>
            <param name="labels">The labels.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperties">The match properties.</param>
            <returns></returns>
            make sure to set unique constraint (on the matching properties),
            otherwise a new node with different concurrency will be created when not match.
            <example><![CDATA[
            CreateOrUpdate("items", new []{"Person", "Dev"}, new[] {"id", "name"}, "p", "map")
            Results in:
            UNWIND items as map 
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p += $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateOrUpdate(System.String,System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For replace use ReplaceOrUpdate.
            </summary>
            <param name="collection">The collection.</param>
            <param name="label">The label.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate("items", "Person", "p", "map", "name")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            SET p += $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateOrUpdate``1(System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For replace use ReplaceOrUpdate
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate<Person>("items", "p", "map", "name")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            SET p += $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateOrUpdate``1(System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Creates the or update.
            For update use UpdateOrUpdate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <param name="matchPropertyExpression">The match property expression.
            It will take the lambda variable as the expression variable.
            this variable will serve as the parameter when parameter is null.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate<Person>("items", p => p.name, "map")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            SET p += $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateOrReplace(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            Creates the or replace.
            </summary>
            <param name="collection">The collection.</param>
            <param name="labels">The labels.</param>
            <param name="matchProperties">The match properties.</param>
            <param name="variable">The variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate("items", new []{"Person", "Dev"}, new[] {"id", "name"}, "p", "map")
            Results in:
            UNWIND items as map 
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateOrReplace(System.String,System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For update use UpdateOrUpdate.
            </summary>
            <param name="collection">The collection.</param>
            <param name="variable">The node variable.</param>
            <param name="label">The label.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrReplace("items", "Person", "p", "map", "name")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateOrReplace``1(System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For update use UpdateOrUpdate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrReplace<Person>("items", "p", "map", "name")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntitiesMutations.CreateOrReplace``1(System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Creates the or replace.
            For update use UpdateOrUpdate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <param name="matchPropertyExpression">The match property expression.
            It will take the lambda variable as the expression variable.
            this variable will serve as the parameter when parameter is null.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrReplace<Person>("items", p => p.name, "map")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            SET p = $map
            ]]></example>
        </member>
        <member name="T:Weknow.ICypherEntityMutations">
            <summary>
            Entity Mutations
            </summary>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateNew(System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            CREATE by entity
            </summary>
            <param name="variable">
            The node's variable.
            When the parameter is null, it will be used as the parameter.
            </param>
            <param name="labels">The labels.</param>
            <param name="parameter">The parameter.</param>
            <returns></returns>
            <example><![CDATA[
            CreateNew("n", new [] {"A", "B"}, "map")
            Results in:
            CREATE (n:A:B $n_map)
            ----------------------------------------------------------
            CreateNew("n", new [] {"A", "B"}, "map", "prefix")
            Results in:
            CREATE (n:A:B $prefix_map)
            ----------------------------------------------------------
            CreateNew("n", new [] {"A", "B"}, "map", "prefix", ".")
            Results in:
            CREATE (n:A:B $prefix.map)
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateNew(System.String,System.String,System.String)">
            <summary>
            Create CREATE instance phrase
            </summary>
            <param name="variable">
            The node's variable.
            When the parameter is null, it will be used as the parameter.
            </param>
            <param name="label">The node's label which will be used for the parameter format (variable_label).</param>
            <param name="parameter">The parameter.</param>
            <returns></returns>
            <example><![CDATA[
            CreateNew("n", "FOO")
            Results in:
            CREATE (n:FOO $n_Foo) // Create a node with the given properties.
            --------------------------------------------------------------------------
            CreateNew("n", "FOO", "map")
            Results in:
            CREATE (n:FOO:DEV $n_map) // Create a node with the given properties.
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateNew``1(System.String,System.String)">
            <summary>
            CREATE by entity
            </summary>
            <typeparam name="T">will be used as the node's label. this label will also use for the parameter format (variable_typeof(T).Name).</typeparam>
            <param name="variable">
            The node's variable.
            When the parameter is null, it will be used as the parameter.
            </param>
            <param name="parameter">The parameter.</param>
            <returns></returns>
            <example><![CDATA[
            CreateNew<Foo>("n")
            Results in:
            CREATE (n:FOO $n_Foo) // Create a node with the given properties.
            --------------------------------------------------------------------------
            CreateNew<Foo>("n", "map")
            Results in:
            CREATE (n:FOO $n_map) // Create a node with the given properties.
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateIfNotExists(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Create if not exists
            </summary>
            <param name="variable">
            The node's variable.
            When the entityParameter is null, it will be used as the entityParameter.
            </param>
            <param name="labels">The labels.</param>
            <param name="entityParameter">The entity parameter.</param>
            <param name="matchProperties">The match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists("p", new []{"Person", "Dev"}, new[] {"id", "name"}, "map")
            Results in:
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateIfNotExists(System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create if not exists
            </summary>
            <param name="variable">The node variable.</param>
            <param name="label">The label.</param>
            <param name="entityParameter">The entity parameter.</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists("p", "Person", "map", "id", "name")
            Results in:
            MERGE (p:Person {id: $map.id, name: $map.name})
                ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateIfNotExists``1(System.String,System.String,System.String,System.String[])">
            <summary>
            Create if not exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The node variable.</param>
            <param name="entityParameter">The entity parameter.</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists<Person>("p", "map", "id", "name")
            Results in:
            MERGE (p:Person {id: $map.id, name: $map.name})
                ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateIfNotExists``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Create if not exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="matchPropertyExpression">
            The match property expression.
            It will take the lambda variable as the expression variable.
            this variable will serve as the entityParameter when entityParameter is null.
            </param>
            <param name="entityParameter">The entity parameter.</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists<Person>(p => p.name, "map")
            MERGE (p:Person {name: $map.name})
            ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateOrUpdate(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Create or update entity.
            For replace use ReplaceOrUpdate
            </summary>
            <param name="variable">The node variable.</param>
            <param name="labels">The labels.</param>
            <param name="entityParameter">The entity parameter.</param>
            <param name="matchProperties">The match properties.</param>
            <returns></returns>
            make sure to set unique constraint (on the matching properties),
            otherwise a new node with different concurrency will be created when not match.
            <example><![CDATA[
            CreateOrUpdate("p", new []{"Person", "Dev"}, new[] {"id", "name"}, "map")
            Results in:
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p += $map
            -------------------------------------------------------------------------
            CreateOrUpdate("p", new []{"Person", "Dev"}, new[] {"id", "name"}, "map", "eTag")
            Results in:
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p += $map, p.eTag = p.eTag + 1
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateOrUpdate(System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For replace use ReplaceOrUpdate.
            </summary>
            <param name="variable">The node variable.</param>
            <param name="label">The label.</param>
            <param name="entityParameter">The entity parameter.</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate("p", "Person", "map", "name")
            
            MERGE (p:Person {name: $map.name})
                SET p += $map
                
            CreateOrUpdate("p", "Person", "map", "name", "more")
            
            MERGE (p:Person {name: $map.name, more: $map.more})
                SET p += $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateOrUpdate``1(System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For replace use ReplaceOrUpdate
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The node variable.</param>
            <param name="entityParameter">The entity parameter.</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate<Person>("p", "map", "name")
            
            MERGE (p:Person {name: $map.name})
                SET p += $map
                
            CreateOrUpdate<Person>("p", "map", "name", "more")
            
            MERGE (p:Person {name: $map.name, more: $map.more})
                SET p += $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateOrUpdate``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Creates the or update.
            For update use UpdateOrUpdate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="matchPropertyExpression">
            The match property expression.
            It will take the lambda variable as the expression variable.
            this variable will serve as the entityParameter when entityParameter is null.
            </param>
            <param name="entityParameter">The entity parameter.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate<Person>(p => p.name, "map")
            MERGE (p:Person {name: $map.name})
            SET p += $map
            ------------------------------------------------
            CreateOrUpdate<Person>(p => p.name, "map", "eTag")
            MERGE (p:Person {name: $map.name})
            SET p += $map, p.eTag = p.eTag + 1
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateOrReplace(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Create or update entity.
            For update use UpdateOrUpdate.
            </summary>
            <param name="variable">The node variable.</param>
            <param name="labels">The labels.</param>
            <param name="entityParameter">The entity parameter.</param>
            <param name="matchProperties">The match properties.</param>
            <returns></returns>
            make sure to set unique constraint (on the matching properties),
            otherwise a new node with different concurrency will be created when not match.
            <example><![CDATA[
            CreateOrUpdate("p", new []{"Person", "Dev"}, new[] {"id", "name"}, "map")
            Results in:
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p = $map
            -----------------------------------------------------------------------------
            CreateOrUpdate("p", new []{"Person", "Dev"}, new[] {"id", "name"}, "map", "eTag")
            Results in:
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p = $map, p.eTag = p.eTag + 1
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateOrReplace(System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For update use UpdateOrUpdate.
            </summary>
            <param name="variable">The node variable.</param>
            <param name="label">The label.</param>
            <param name="entityParameter">The entity parameter.</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrReplace("p", "Person", "map", "name")
            
            MERGE (p:Person {name: $map.name})
                ON CREATE SET p = $map
                
            CreateOrReplace("p", "Person", "map", "name", "more")
            
            MERGE (p:Person {name: $map.name, more: $map.more})
                SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateOrReplace``1(System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For update use UpdateOrUpdate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The node variable.</param>
            <param name="entityParameter">The entity parameter.</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrReplace<Person>("p", "map", "name")
            
            MERGE (p:Person {name: $map.name})
                SET p = $map
                
            CreateOrReplace<Person>("p", "map", "name", "more")
            
            MERGE (p:Person {name: $map.name, more: $map.more})
                SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.ICypherEntityMutations.CreateOrReplace``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Creates the or replace.
            For update use UpdateOrUpdate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="matchPropertyExpression">
            The match property expression.
            It will take the lambda variable as the expression variable.
            this variable will serve as the entityParameter when entityParameter is null.
            </param>
            <param name="entityParameter">The entity parameter.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrReplace<Person>(p => p.name, "map")
            Results in:
            MERGE (p:Person {name: $map.name})
            SET p = $map
            ---------------------------------------------------------
            CreateOrReplace<Person>(p => p.name, "map", "eTag")
            Results in:
            MERGE (p:Person {name: $map.name})
            SET p = $map, p.eTag = p.eTag + 1
            ]]></example>
        </member>
        <member name="T:Weknow.ConcurrencyConfig">
            <summary>
            Represent contextual operations.
            </summary>
        </member>
        <member name="P:Weknow.ConcurrencyConfig.eTagName">
            <summary>
            When supplied the concurrency field
            used for incrementing the concurrency version (Optimistic concurrency)
            make sure to set unique constraint (on the matching properties),
            otherwise a new node with different concurrency will be created when not match.
            </summary>
        </member>
        <member name="P:Weknow.ConcurrencyConfig.AutoIncrement">
            <summary>
            Gets or sets a value indicating whether [automatic increment].
            </summary>
            <value>
              <c>true</c> if [automatic increment]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Weknow.CypherAmbientLabelConfig">
            <summary>
            Label configuration
            </summary>
        </member>
        <member name="M:Weknow.CypherAmbientLabelConfig.#ctor(Weknow.CypherNamingConfig)">
            <summary>
            Initializes a new instance of the <see cref="T:Weknow.CypherAmbientLabelConfig"/> class.
            </summary>
            <param name="namingConfig">The naming configuration.</param>
        </member>
        <member name="P:Weknow.CypherAmbientLabelConfig.Values">
            <summary>
            Gets the additional ambient labels which will be added to cypher queries
            (when the expression is not hard-codded string).
            </summary>
        </member>
        <member name="P:Weknow.CypherAmbientLabelConfig.Formatter">
            <summary>
            Gets or sets the formatter label formatter.
            For example "`@{0}`"
            </summary>
        </member>
        <member name="M:Weknow.CypherAmbientLabelConfig.Add(System.String[])">
            <summary>
            Adds the additional ambient labels which will be added to cypher queries.
            </summary>
            <param name="additionalLabels">The additional labels.</param>
        </member>
        <member name="M:Weknow.CypherAmbientLabelConfig.Combine(System.String[])">
            <summary>
            Get combined label string with ambient and additional labels.
            </summary>
            <param name="additionalLabels">The labels.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherAmbientLabelConfig.Combine(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Get combined label string with ambient and additional labels.
            </summary>
            <param name="additionalLabels">The labels.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherAmbientLabelConfig.AmbientFormat(System.String)">
            <summary>
            Ambients the format.
            </summary>
            <param name="text">The text.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherAmbientLabelConfig.FormatByConvention``1(``0)">
            <summary>
            Formats the specified text.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="text">The text.</param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException">text</exception>
        </member>
        <member name="M:Weknow.CypherAmbientLabelConfig.Clone(System.String[])">
            <summary>
            Clones the specified additional ambient labels.
            </summary>
            <param name="additionalAmbientLabels">The additional ambient labels.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherAmbientLabelConfig.ToString">
            <summary>
            Converts to string.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:Weknow.CypherConfig">
            <summary>
            The cypher builder configuration.
            </summary>
        </member>
        <member name="M:Weknow.CypherConfig.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Weknow.CypherConfig"/> class.
            </summary>
        </member>
        <member name="P:Weknow.CypherConfig.AmbientLabels">
            <summary>
            Ambient Label configuration
            </summary>
        </member>
        <member name="P:Weknow.CypherConfig.Weknow#ICypherConfig#AmbientLabels">
            <summary>
            Ambient Label configuration
            </summary>
        </member>
        <member name="P:Weknow.CypherConfig.Concurrency">
            <summary>
            Sets the concurrency behavior.
            </summary>
        </member>
        <member name="P:Weknow.CypherConfig.Weknow#ICypherConfig#Concurrency">
            <summary>
            Sets the concurrency behavior.
            </summary>
        </member>
        <member name="P:Weknow.CypherConfig.Naming">
            <summary>
            Gets the naming convention.
            </summary>
        </member>
        <member name="T:Weknow.CypherNamingConfig">
            <summary>
            Naming convention
            </summary>
        </member>
        <member name="P:Weknow.CypherNamingConfig.NodeLabelConvention">
            <summary>
            Gets or sets the node label convention.
            </summary>
        </member>
        <member name="P:Weknow.CypherNamingConfig.RelationTagConvention">
            <summary>
            Gets or sets the relation tag convention.
            </summary>
        </member>
        <member name="T:Weknow.IConcurrencyConfig">
            <summary>
            Represent contextual operations.
            </summary>
        </member>
        <member name="P:Weknow.IConcurrencyConfig.eTagName">
            <summary>
            When supplied the concurrency field
            used for incrementing the concurrency version (Optimistic concurrency)
            make sure to set unique constraint (on the matching properties),
            otherwise a new node with different concurrency will be created when not match.
            </summary>
        </member>
        <member name="P:Weknow.IConcurrencyConfig.AutoIncrement">
            <summary>
            Gets or sets a value indicating whether [automatic increment].
            </summary>
            <value>
              <c>true</c> if [automatic increment]; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Weknow.ICypherAmbientLabelConfig">
            <summary>
            Ambient Label configuration
            Use ToString() in order to get formatted labels
            </summary>
        </member>
        <member name="P:Weknow.ICypherAmbientLabelConfig.Values">
            <summary>
            Gets the additional ambient labels which will be added to cypher queries
            (when the expression is not hard-codded string).
            </summary>
        </member>
        <member name="P:Weknow.ICypherAmbientLabelConfig.Formatter">
            <summary>
            Gets or sets the formatter label formatter.
            For example "`@{0}`"
            </summary>
        </member>
        <member name="T:Weknow.ICypherConfig">
            <summary>
            The cypher builder configuration.
            </summary>
        </member>
        <member name="P:Weknow.ICypherConfig.AmbientLabels">
            <summary>
            Ambient Label configuration.
            </summary>
        </member>
        <member name="P:Weknow.ICypherConfig.Concurrency">
            <summary>
            Sets the concurrency behavior.
            </summary>
        </member>
        <member name="T:Weknow.FluentCypherReturn">
            <summary>
            Fluent Cypher Return phrase
            </summary>
            <seealso cref="T:Weknow.FluentCypher" />
        </member>
        <member name="M:Weknow.FluentCypherReturn.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Weknow.FluentCypherWhereExpression"/> class from being created.
            </summary>
        </member>
        <member name="M:Weknow.FluentCypherReturn.#ctor(Weknow.CypherConfig)">
            <summary>
            Initialize constructor
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Weknow.FluentCypherReturn.#ctor(Weknow.FluentCypher,System.String,Weknow.CypherPhrase,System.String,System.Collections.Generic.IEnumerable{Weknow.FluentCypher},System.String,Weknow.CypherConfig)">
            <summary>
            Initializes a new instance of the <see cref="T:Weknow.FluentCypherReturn" /> class.
            </summary>
            <param name="copyFrom">The copy from.</param>
            <param name="cypher">The cypher.</param>
            <param name="phrase">The phrase.</param>
            <param name="cypherClose">The cypher close.</param>
            <param name="children">The children.</param>
            <param name="childrenSeparator">The children separator.</param>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Weknow.FluentCypherReturn.OrderBy(System.String)">
            <summary>
            Create ORDER BY phrase.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            ORDER BY n.property
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypherReturn.OrderByDesc(System.String)">
            <summary>
            Create ORDER BY DESC phrase.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            ORDER BY n.property DESC
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypherReturn.Skip(System.String)">
            <summary>
            Create SKIP phrase.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            SKIP $skipNumber
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypherReturn.Skip(System.Int32)">
            <summary>
            Create SKIP phrase.
            </summary>
            <param name="number">The number.</param>
            <returns></returns>
            <example><![CDATA[
            SKIP 10
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypherReturn.Limit(System.String)">
            <summary>
            Create LIMIT phrase.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            LIMIT $skipNumber
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypherReturn.Limit(System.Int32)">
            <summary>
            Create LIMIT phrase.
            </summary>
            <param name="number">The number.</param>
            <returns></returns>
            <example><![CDATA[
            LIMIT 10
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypherReturn.Count">
            <summary>
            Create count function.
            </summary>
            <returns></returns>
            <example><![CDATA[
            RETURN count(*)
            ]]></example>
        </member>
        <member name="T:Weknow.FluentCypherSet`1">
            <summary>
            Additional Sets phrases
            </summary>
            <typeparam name="T"></typeparam>
            <seealso cref="T:Weknow.CypherBuilder" />
        </member>
        <member name="M:Weknow.FluentCypherSet`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Weknow.FluentCypherSet`1"/> class.
            </summary>
        </member>
        <member name="M:Weknow.FluentCypherSet`1.#ctor(Weknow.CypherBuilder,System.String,Weknow.CypherPhrase)">
            <summary>
            Initializes a new instance of the <see cref="T:Weknow.FluentCypherSet`1"/> class.
            </summary>
            <param name="copyFrom">The copy from.</param>
            <param name="cypher">The cypher.</param>
            <param name="phrase">The phrase.</param>
        </member>
        <member name="M:Weknow.FluentCypherSet`1.SetMore(System.Linq.Expressions.Expression{System.Func{`0,System.Object}},System.String,System.String)">
            <summary>
            Compose SET phrase from a type expression.
            </summary>
            <param name="propExpression">The property expression.</param>
            <param name="parameterPrefix">The parameter prefix.</param>
            <param name="parameterSign">The parameter sign.</param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
            <example><![CDATA[
            Set((User user) =&gt; user.Name).Also(user =&gt; user.Id)
            SET user.Name = $user.Name, user.Id = $user.Id // Update or create a property.
            ]]></example>
        </member>
        <member name="T:Weknow.FluentCypherSetExclude`1">
            <summary>
            Excludes Set phrases
            </summary>
            <typeparam name="T"></typeparam>
            <seealso cref="T:Weknow.FluentCypher" />
        </member>
        <member name="M:Weknow.FluentCypherSetExclude`1.Exclude(System.Linq.Expressions.Expression{System.Func{`0,System.Object}})">
            <summary>
            Compose SET phrase from a type expression.
            </summary>
            <param name="propExpression">The property expression.</param>
            <returns></returns>
            <example><![CDATA[
            Set<User>().Exclude(user => user.Other)
            SET user.Id = $Id, user.Name = $Name // Update or create a property.
            ]]></example>
        </member>
        <member name="T:Weknow.FluentCypherWhereExpression">
            <summary>
            Extends the phrases option under WHERE context
            </summary>
            <seealso cref="T:Weknow.FluentCypher" />
        </member>
        <member name="M:Weknow.FluentCypherWhereExpression.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Weknow.FluentCypherWhereExpression"/> class from being created.
            </summary>
        </member>
        <member name="M:Weknow.FluentCypherWhereExpression.#ctor(Weknow.CypherConfig)">
            <summary>
            Initialize constructor
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Weknow.FluentCypherWhereExpression.#ctor(Weknow.FluentCypher,System.String,Weknow.CypherPhrase,System.String,System.Collections.Generic.IEnumerable{Weknow.FluentCypher},System.String,Weknow.CypherConfig)">
            <summary>
            Initializes a new instance of the <see cref="T:Weknow.FluentCypherWhereExpression" /> class.
            </summary>
            <param name="copyFrom">The copy from.</param>
            <param name="cypher">The cypher.</param>
            <param name="phrase">The phrase.</param>
            <param name="cypherClose">The cypher close.</param>
            <param name="children">The children.</param>
            <param name="childrenSeparator">The children separator.</param>
            <param name="config">The configuration.</param>
        </member>
        <member name="P:Weknow.FluentCypherWhereExpression.And">
            <summary>
            Compose AND phrase.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Weknow.FluentCypherWhereExpression.Or">
            <summary>
            Compose OR phrase.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Weknow.C">
            <summary>
            Fluent cypher builder
            </summary>
            <seealso cref="T:Weknow.FluentCypher" />
        </member>
        <member name="M:Weknow.C.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Weknow.C"/> class from being created.
            </summary>
        </member>
        <member name="M:Weknow.C.#ctor(System.String,Weknow.CypherPhrase,System.String,System.Collections.Generic.IEnumerable{Weknow.FluentCypher},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Weknow.C"/> class.
            </summary>
            <param name="cypher">The cypher.</param>
            <param name="phrase">The phrase.</param>
            <param name="cypherClose">The cypher close.</param>
            <param name="children">The children.</param>
            <param name="childrenSeparator">The children separator.</param>
        </member>
        <member name="M:Weknow.C.#ctor(Weknow.FluentCypher,System.String,Weknow.CypherPhrase,System.String,System.Collections.Generic.IEnumerable{Weknow.FluentCypher},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Weknow.C"/> class.
            </summary>
            <param name="copyFrom">The copy from.</param>
            <param name="cypher">The cypher.</param>
            <param name="phrase">The phrase.</param>
            <param name="cypherClose">The cypher close.</param>
            <param name="children">The children.</param>
            <param name="childrenSeparator">The children separator.</param>
        </member>
        <member name="T:Weknow.CypherBuilder">
            <summary>
            Fluent cypher builder
            </summary>
            <seealso cref="T:Weknow.FluentCypherWhereExpression" />
            <seealso cref="T:Weknow.ICypherEntityMutations" />
            <seealso cref="T:Weknow.ICypherEntitiesMutations" />
            <seealso cref="T:Weknow.FluentCypher" />
        </member>
        <member name="M:Weknow.CypherBuilder.Create(System.Action{Weknow.CypherConfig})">
            <summary>
            Root Cypher Builder with configuration.
            </summary>
        </member>
        <member name="F:Weknow.CypherBuilder.Default">
            <summary>
            Root Cypher Builder.
            </summary>
        </member>
        <member name="M:Weknow.CypherBuilder.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Weknow.FluentCypher" /> class from being created.
            </summary>
        </member>
        <member name="M:Weknow.CypherBuilder.#ctor(Weknow.CypherConfig)">
            <summary>
            Initialize constructor
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Weknow.CypherBuilder.#ctor(System.String,Weknow.CypherPhrase,System.String,System.Collections.Generic.IEnumerable{Weknow.FluentCypher},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Weknow.CypherBuilder" /> class.
            </summary>
            <param name="cypher">The cypher.</param>
            <param name="phrase">The phrase.</param>
            <param name="cypherClose">The cypher close.</param>
            <param name="children">The children.</param>
            <param name="childrenSeparator">The children separator.</param>
        </member>
        <member name="M:Weknow.CypherBuilder.#ctor(Weknow.FluentCypher,System.String,Weknow.CypherPhrase,System.String,System.Collections.Generic.IEnumerable{Weknow.FluentCypher},System.String,Weknow.CypherConfig)">
            <summary>
            Initializes a new instance of the <see cref="T:Weknow.CypherBuilder" /> class.
            </summary>
            <param name="copyFrom">The copy from.</param>
            <param name="cypher">The cypher.</param>
            <param name="phrase">The phrase.</param>
            <param name="cypherClose">The cypher close.</param>
            <param name="children">The children.</param>
            <param name="childrenSeparator">The children separator.</param>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Weknow.CypherBuilder.IsWithCause(Weknow.CypherPhrase)">
            <summary>
            Determines whether previous occurrence of phrase is cause for a WITH.  
            </summary>
            <param name="phrase">The phrase.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.IsWithCandidate(Weknow.CypherPhrase)">
            <summary>
            Determines a phrase should cause checking previous phrases for cause of using WITH.  
            </summary>
            <param name="phrase">The phrase.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.AddStatement(Weknow.CypherPhrase)">
            <summary>
            Adds a statement.
            </summary>
            <param name="phrase">The phrase.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.AddStatement(System.String,Weknow.CypherPhrase)">
            <summary>
            Adds a statement.
            </summary>
            <param name="statement">The statement.</param>
            <param name="phrase">The phrase.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.AddStatement``1(System.String,Weknow.CypherPhrase)">
            <summary>
            Adds a statement.
            </summary>
            <param name="statement">The statement.</param>
            <param name="phrase">The phrase.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.AddAmbientLabels(System.String[])">
            <summary>
            Adds the ambient labels.
            additional ambient labels which will be added to cypher queries
            (when the expression is not hard-codded string).
            </summary>
            <param name="labels">The labels.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.Generate(System.String)">
            <summary>
            Adds a statement (any valid cypher query).
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.Generate(System.Func{Weknow.FluentCypher,Weknow.FluentCypher},Weknow.CypherPhrase,System.String,System.String)">
            <summary>
            Adds the fluent cypher.
            </summary>
            <param name="expression">The delegate expression.</param>
            <param name="phrase">The phrase.</param>
            <param name="openCypher">The open cypher.</param>
            <param name="closeCypher">The close cypher.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.Generate(Weknow.FluentCypher,System.String,Weknow.FluentCypher[])">
            <summary>
            Adds the fluent cypher.
            </summary>
            <param name="child">The child.</param>
            <param name="childrenSeparator">The children separator (space if empty).</param>
            <param name="moreChildren">The more children.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.Generate(System.Collections.Generic.IEnumerable{Weknow.FluentCypher},System.String,Weknow.CypherPhrase,System.String,System.String)">
            <summary>
            Adds the fluent cypher.
            </summary>
            <param name="children">The delegated.</param>
            <param name="childrenSeparator">The children separator (space if empty).</param>
            <param name="phrase">The phrase.</param>
            <param name="openCypher">The open cypher.</param>
            <param name="closeCypher">The close cypher.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.Add(System.String)">
            <summary>
            Adds a statement (any valid cypher query).
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.Match(System.String)">
            <summary>
            Create MATCH phrase
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MATCH (n:Person)-[:KNOWS]->(m:Person)
            MATCH (n)-->(m)
            MATCH (n {name: 'Alice'})-->(m)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.OptionalMatch(System.String)">
            <summary>
            Create OPTIONAL MATCH phrase
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            OPTIONAL MATCH (n)-[r]->(m)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Create(System.String)">
            <summary>
            Create CREATE phrase
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            CREATE (n {name: $value}) // Create a node with the given properties.
            CREATE (n $map) // Create a node with the given properties.
            CREATE (n) SET n = properties // Create nodes with the given properties.
            CREATE (n)-[r:KNOWS]->(m) // Create a relationship with the given type and direction; bind a variable to it.
            CREATE (n)-[:LOVES {since: $value}]->(m) // Create a relationship with the given type, direction, and properties.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Merge(System.String)">
            <summary>
            Create MERGE phrase.
            Match a pattern or create it if it does not exist. 
            Use ON CREATE and ON MATCH for conditional updates.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET 
              n.counter = coalesce(n.counter, 0) + 1,
              n.accessTime = timestamp()
            ------------------------------------------  
            MATCH (a:Person {name: $value1}),
                  (b:Person {name: $value2})
            MERGE(a)-[r: LOVES]->(b)
            ------------------------------------------
            MATCH (a:Person {name: $value1})
            MERGE (a)-[r: KNOWS]->(b:Person {name: $value3})
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.OnCreate">
            <summary>
            Compose ON CREATE phrase.
            Match a pattern or create it if it does not exist. 
            Use ON CREATE and ON MATCH for conditional updates.
            </summary>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            
              n.counter = coalesce(n.counter, 0) + 1,
              n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.OnCreate(System.String)">
            <summary>
            Compose ON CREATE phrase.
            Match a pattern or create it if it does not exist.
            Use ON CREATE and ON MATCH for conditional updates.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            n.counter = coalesce(n.counter, 0) + 1,
            n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.OnMatch">
            <summary>
            Compose ON MATCH phrase
            Match a pattern or create it if it does not exist. 
            Use ON CREATE and ON MATCH for conditional updates.
            </summary>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            
              n.counter = coalesce(n.counter, 0) + 1,
              n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.OnMatch(System.String)">
            <summary>
            Compose ON MATCH phrase
            Match a pattern or create it if it does not exist.
            Use ON CREATE and ON MATCH for conditional updates.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            n.counter = coalesce(n.counter, 0) + 1,
            n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.OnMatchSet(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Compose ON MATCH SET phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="propNames">The property names.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            n.counter = coalesce(n.counter, 0) + 1,
            n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.OnMatchSet(System.String,System.String,System.String[])">
            <summary>
            Compose ON MATCH SET phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="name">The name.</param>
            <param name="moreNames">The more names.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            n.counter = coalesce(n.counter, 0) + 1,
            n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.OnMatchSet``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Compose ON MATCH SET phrase from a type expression.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="propExpression">The property expression.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            n.counter = coalesce(n.counter, 0) + 1,
            n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.OnMatchSetByConvention``1(System.String,System.Func{System.String,System.Boolean})">
            <summary>
            Compose ON MATCH SET phrase by convention.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="filter">The filter.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            n.counter = coalesce(n.counter, 0) + 1,
            n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Remove(System.String)">
            <summary>
            Create REMOVE phrase,
            Remove the label from the node or property.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            REMOVE n:Person // Remove a label from n.
            REMOVE n.property // Remove a property.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Delete(System.String)">
            <summary>
            Create DELETE  phrase,
            Delete a node and a relationship.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MATCH (n)
            DETACH DELETE n
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.DetachDelete(System.String)">
            <summary>
            Create DETACH DELETE phrase,
            Delete all nodes and relationships from the database.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MATCH (n)
            DETACH DELETE n
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Unwind(System.String,System.String,System.String)">
            <summary>
            Create UNWIND phrase.
            With UNWIND, any list can be transformed back into individual rows.
            The example matches all names from a list of names.
            </summary>
            <param name="collection">The collection.</param>
            <param name="variable">The variable.</param>
            <param name="collectionSign">The collection sign.</param>
            <returns></returns>
            <example><![CDATA[
            Unwind("names", "name")
            Results in:
            UNWIND $names AS name
            -------------------------
            Unwind("names", "name", string.Empty)
            Results in:
            UNWIND names AS name
            -------------------------
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.With(System.String)">
            <summary>
            Create WITH  phrase.
            WThe WITH syntax is similar to RETURN.
            It separates query parts explicitly,
            allowing you to declare which variables to carry over to the next part.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MATCH (user)-[:FRIEND]-(friend)
            WHERE user.name = $name
            WITH user, count(friend) AS friends
            WHERE friends &gt; 10
            RETURN user
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Return">
            <summary>
            Create RETURN phrase.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.Return(System.String)">
            <summary>
            Create RETURN phrase.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            RETURN * // Return the value of all variables.
            RETURN n AS columnName // Use alias for result column name.
            RETURN DISTINCT n // Return unique rows.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Return``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Create RETURN phrase.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            .Return<Foo>(f => f.Name)
            RETURN f.Name
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.ReturnDistinct(System.String)">
            <summary>
            Create RETURN DISTINCT phrase.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            RETURN DISTINCT n // Return unique rows.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.ReturnDistinct``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Create RETURN DISTINCT phrase.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            .ReturnDistinct<Foo>(f => f.Name)
            RETURN DISTINCT f.Name
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Union">
            <summary>
            Create UNION phrase.
            Returns the distinct union of all query results.
            Result column types and names have to match.
            </summary>
            <returns></returns>
            <example><![CDATA[
            MATCH (a)-[:KNOWS]->(b)
            RETURN b.name
            UNION
            MATCH (a)-[:LOVES]->(b)
            RETURN b.name
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.UnionAll">
            <summary>
            Create UNION ALL phrase.
            Returns the distinct union of all query results.
            Result column types and names have to match.
            Including duplicated rows.
            </summary>
            <returns></returns>
            <example><![CDATA[
            MATCH (a)-[:KNOWS]->(b)
            RETURN b.name
            UNION All
            MATCH (a)-[:LOVES]->(b)
            RETURN b.name
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Call(System.String)">
            <summary>
            Create CALL phrase,
            Delete a node and a relationship.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            CALL db.labels() YIELD label
            This shows a standalone call to the built-in
            procedure db.labels to list all labels used in the database.
            Note that required procedure arguments are given explicitly
            in brackets after the procedure name.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Set(System.String)">
            <summary>
            Compose SET phrase
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            SET n.property1 = $value1, n.property2 = $value2 // Update or create a property.
            SET n = $map // Update or create a property.
            SET n += $map // Add and update properties, while keeping existing ones.
            SET n:Person // Adds a label Person to a node.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Set(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            Compose SET phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="propNames">The property names.</param>
            <param name="parameterPrefix">The parameter prefix.</param>
            <param name="parameterSign">The parameter sign.</param>
            <returns></returns>
            <example><![CDATA[
            Set("n", new [] { nameof(Foo.Name), nameof(Bar.Id)})
            SET n.Name = $Name, n.Id = $Id // Update or create a property.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Set(System.String,System.String,System.String[])">
            <summary>
            Compose SET phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="name">The name.</param>
            <param name="moreNames">The more names.</param>
            <returns></returns>
            <example><![CDATA[
            Set("n", nameof(Foo.Name), nameof(Bar.Id))
            SET n.Name = $Name, n.Id = $Id // Update or create a property.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Set``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String,System.String)">
            <summary>
            Compose SET phrase from a type expression.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="propExpression">The property expression.</param>
            <param name="parameterPrefix">The parameter prefix.</param>
            <param name="parameterSign">The parameter sign.</param>
            <returns></returns>
            <example><![CDATA[
            Set((User user) => user.Name)
            SET user.Name = $Name // Update or create a property.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.SetAll``1(System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Object}}[])">
            <summary>
            Set all properties (optional with excludes).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="excludes">The excludes.</param>
            <returns></returns>
            <example><![CDATA[
            Set<UserEntity>("u")
            SET u = $UserEntity
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.SetEntity(System.String,System.String,System.String,Weknow.SetInstanceBehavior)">
            <summary>
            Sets the entity.
            </summary>
            <param name="variable">The variable.</param>
            <param name="paramName">Name of the parameter.</param>
            <param name="parameterSign">The parameter sign ($ or nothing).</param>
            <param name="behavior">The behavior.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.SetEntity(System.String,System.String,Weknow.SetInstanceBehavior)">
            <summary>
            Set instance. 
            Behaviors:
            Replace: This will remove any existing properties.
            Update: update properties, while keeping existing ones.
            </summary>
            <param name="variable">The variable.</param>
            <param name="paramName"></param>
            <param name="behavior"></param>
            <returns></returns>
            <example><![CDATA[
            Set("u", "entity")
            SET u = $u_entity
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.SetEntity``1(System.String,Weknow.SetInstanceBehavior)">
            <summary>
            Set instance.
            Behaviors:
            Replace: This will remove any existing properties.
            Update: update properties, while keeping existing ones.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="behavior">The behavior.</param>
            <returns></returns>
            <example><![CDATA[
            Set<UserEntity>("u")
            SET u = $UserEntity
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.SetEntity``1(System.String,System.String,Weknow.SetInstanceBehavior)">
            <summary>
            Set instance.
            Behaviors:
            Replace: This will remove any existing properties.
            Update: update properties, while keeping existing ones.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="parameterPrefix">The parameter prefix.</param>
            <param name="behavior">The behavior.</param>
            <returns></returns>
            <example><![CDATA[
            Set<UserEntity>("u")
            SET u = $UserEntity
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.SetByConvention``1(System.String,System.Func{System.String,System.Boolean})">
            <summary>
            Compose SET phrase by convention.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="filter">The filter.</param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
            <example><![CDATA[
            Set((User user) =&gt; user.Name.StartWith("Name"))
            SET user.FirstName = $FirstName, usr.LastName = $LastName // Update or create a property.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.SetLabel(System.String,System.String)">
            <summary>
            Sets the label.
            </summary>
            <param name="variable">The variable.</param>
            <param name="label">The label.</param>
            <returns></returns>
            <example><![CDATA[
            SET n:Person
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Where(System.String)">
            <summary>
            Create WHERE phrase
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            WHERE n.property <> $value
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Where(System.String,System.String,System.String[])">
            <summary>
            Create WHERE phrase with AND semantic between each term
            </summary>
            <param name="variable">The variable.</param>
            <param name="name">The name.</param>
            <param name="moreNames">The more names.</param>
            <returns></returns>
            <example><![CDATA[
            Where ("n", "A", "B")
            Result with
            WHERE n.A = $n_A AND n.B = $n_B
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Where(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Create WHERE phrase with AND semantic between each term
            </summary>
            <param name="variable">The variable.</param>
            <param name="names">The property names.</param>
            <returns></returns>
            <example><![CDATA[
            Where ("n", new [] {"A", "B"})
            Result with
            WHERE n.A = $n_A AND n.B = $n_B
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Where``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String,System.String,System.String)">
            <summary>
            Create WHERE phrase, generated by expression
            </summary>
            <typeparam name="T"></typeparam>
            <param name="propExpression">The property expression.</param>
            <param name="parameterPrefix">The parameter prefix.</param>
            <param name="parameterSign">The parameter sign.</param>
            <param name="compareSign">The compare sign.</param>
            <returns></returns>
            <example><![CDATA[
            Where ((User user) => user.Id))
            Result with
            WHERE user.Id = $user_Id
            Where ((User user) => user.Id), ">")
            Result with
            WHERE user.Id > $user_Id AND
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.ForEach(System.String)">
            <summary>
            Compose ForEach phrase
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            FOREACH (r IN relationships(path) | SET r.marked = true)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.ForEach(System.String,System.String,System.String[])">
            <summary>
            Compose ForEach phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="collection">The collection.</param>
            <param name="propNames">The property names.</param>
            <returns></returns>
            <example><![CDATA[
            ForEach("n", "nations", nameof(Foo.Name), nameof(Bar.Id))
            FOREACH (n IN nations | SET n.Name = $n.Name, n.Id = $n.Id)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.ForEach(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Compose ForEach phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="collection">The collection.</param>
            <param name="propNames">The property names.</param>
            <returns></returns>
            <example><![CDATA[
            ForEach("n", "nations", new [] {nameof(Foo.Name), nameof(Bar.Id)})
            FOREACH (n IN nations | SET n.Name = $n.Name, n.Id = $n.Id)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.ForEachByConvention``1(System.String,System.String,System.Func{System.String,System.Boolean})">
            <summary>
            Compose ForEach phrase by convention.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="collection">The collection.</param>
            <param name="filter">The filter.</param>
            <returns></returns>
            <example><![CDATA[
            ForEach("$users", name =&gt; name.EndsWith("Name"))
            ForEach(user IN $users | SET user.FirstName = $user.FirstName, user.LastName = $user.LastName) // Update or create a property.
            ]]></example>
        </member>
        <member name="P:Weknow.CypherBuilder.And">
            <summary>
            Compose AND phrase.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Weknow.CypherBuilder.Or">
            <summary>
            Compose OR phrase.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.OrderBy(System.String)">
            <summary>
            Create ORDER BY phrase.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            ORDER BY n.property
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.OrderByDesc(System.String)">
            <summary>
            Create ORDER BY DESC phrase.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            ORDER BY n.property DESC
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Skip(System.String)">
            <summary>
            Create SKIP phrase.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            SKIP $skipNumber
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Skip(System.Int32)">
            <summary>
            Create SKIP phrase.
            </summary>
            <param name="number">The number.</param>
            <returns></returns>
            <example><![CDATA[
            SKIP 10
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Limit(System.String)">
            <summary>
            Create LIMIT phrase.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            LIMIT $skipNumber
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Limit(System.Int32)">
            <summary>
            Create LIMIT phrase.
            </summary>
            <param name="number">The number.</param>
            <returns></returns>
            <example><![CDATA[
            LIMIT 10
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.As(System.String)">
            <summary>
            Create As phrase
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
            <example><![CDATA[
            collect(list) AS items
            /// ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Count">
            <summary>
            Create count function.
            </summary>
            <returns></returns>
            <example><![CDATA[
            RETURN count(*)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Composite(System.Func{Weknow.FluentCypher,Weknow.FluentCypher},Weknow.CypherPhrase,System.String,System.String)">
            <summary>
            Adds the fluent cypher.
            </summary>
            <param name="expression">The delegate expression.</param>
            <param name="phrase">The phrase.</param>
            <param name="openCypher">The open cypher.</param>
            <param name="closeCypher">The close cypher.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.Composite(Weknow.FluentCypher,System.String,Weknow.FluentCypher[])">
            <summary>
            Adds the fluent cypher.
            </summary>
            <param name="child">The child.</param>
            <param name="childrenSeparator">The children separator (space if empty).</param>
            <param name="moreChildren">The more children.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.Composite(Weknow.FluentCypher,Weknow.CypherPhrase,System.String,System.String,System.String,Weknow.FluentCypher[])">
            <summary>
            Adds the fluent cypher.
            </summary>
            <param name="child">The child.</param>
            <param name="phrase">The phrase.</param>
            <param name="openCypher">The open cypher.</param>
            <param name="closeCypher">The close cypher.</param>
            <param name="childrenSeparator">The children separator (space if empty).</param>
            <param name="moreChildren">The more children.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherBuilder.Composite(System.Collections.Generic.IEnumerable{Weknow.FluentCypher},System.String,Weknow.CypherPhrase,System.String,System.String)">
            <summary>
            Adds the fluent cypher.
            </summary>
            <param name="children">The delegated.</param>
            <param name="childrenSeparator">The children separator (space if empty).</param>
            <param name="phrase">The phrase.</param>
            <param name="openCypher">The open cypher.</param>
            <param name="closeCypher">The close cypher.</param>
            <returns></returns>
        </member>
        <member name="P:Weknow.CypherBuilder.Entity">
            <summary>
            Node mutation by entity.
            </summary>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateNew(System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            CREATE by entity
            </summary>
            <param name="variable">
            The node's variable.
            When the parameter is null, it will be used as the parameter.
            </param>
            <param name="labels">The labels.</param>
            <param name="parameter">The parameter.</param>
            <returns></returns>
            <example><![CDATA[
            CreateNew("n", new [] {"A", "B"}, "map")
            Results in:
            CREATE (n:A:B $n_map)
            ----------------------------------------------------------
            CreateNew("n", new [] {"A", "B"}, "map", "prefix")
            Results in:
            CREATE (n:A:B $prefix_map)
            ----------------------------------------------------------
            CreateNew("n", new [] {"A", "B"}, "map", "prefix", ".")
            Results in:
            CREATE (n:A:B $prefix.map)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateNew(System.String,System.String,System.String)">
            <summary>
            CREATE by entity
            </summary>
            <param name="variable">
            The node's variable.
            When the parameter is null, it will be used as the parameter.
            </param>
            <param name="label">The node's label which will be used for the parameter format (variable_label).</param>
            <param name="parameter">The parameter.</param>
            <returns></returns>
            <example><![CDATA[
            CreateNew("n", "FOO")
            Results in:
            CREATE (n:FOO $n_Foo) // Create a node with the given properties.
            --------------------------------------------------------------------------
            CreateNew("n", "FOO", "dev")
            Results in:
            CREATE (n:FOO:DEV $n_Foo) // Create a node with the given properties.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateNew``1(System.String,System.String)">
            <summary>
            CREATE by entity
            </summary>
            <typeparam name="T">will be used as the node's label. this label will also use for the parameter format (variable_typeof(T).Name).</typeparam>
            <param name="variable">
            The node's variable.
            When the parameter is null, it will be used as the parameter.
            </param>
            <param name="parameter">The parameter.</param>
            <returns></returns>
            <example><![CDATA[
            CreateNew<Foo>("n")
            Results in:
            CREATE (n:FOO $n_Foo) // Create a node with the given properties.
            --------------------------------------------------------------------------
            CreateNew<Foo>("n", "map")
            Results in:
            CREATE (n:FOO $n_map) // Create a node with the given properties.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateIfNotExists(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Create if not exists
            </summary>
            <param name="variable">
            The node's variable.
            When the parameter is null, it will be used as the parameter.
            </param>
            <param name="labels">The labels.</param>
            <param name="matchProperties">The match properties.</param>
            <param name="parameter">The entity parameter.</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists("p", new []{"Person", "Dev"}, new[] {"id", "name"}, "map")
            Results in:
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateIfNotExists(System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create if not exists
            </summary>
            <param name="variable">The node variable.</param>
            <param name="label">The label.</param>
            <param name="parameter">The entity parameter.</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists("p", "Person", "map", "id", "name")
            Results in:
            MERGE (p:Person {id: $map.id, name: $map.name})
                ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateIfNotExists``1(System.String,System.String,System.String,System.String[])">
            <summary>
            Create if not exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The node variable.</param>
            <param name="parameter">The entity parameter.</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists<Person>("p", "map", "id", "name")
            Results in:
            MERGE (p:Person {id: $map.id, name: $map.name})
                ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateIfNotExists``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Create if not exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="matchPropertyExpression">
            The match property expression.
            It will take the lambda variable as the expression variable.
            this variable will serve as the parameter when parameter is null.
            </param>
            <param name="parameter">The entity parameter.</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists<Person>(p => p.name, "map")
            MERGE (p:Person {name: $map.name})
            ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.AddOrModify(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Collections.Generic.IEnumerable{System.String},Weknow.SetInstanceBehavior,System.String,Weknow.FluentCypher)">
            <summary>
            Add or Modify entity.
            For replace use ReplaceOrUpdate.
            </summary>
            <param name="variable">The node variable.</param>
            <param name="labels">The labels.</param>
            <param name="parameter">The entity parameter.</param>
            <param name="matchProperties">The match properties.</param>
            <param name="onMatchBehavior">The behavior.</param>
            <param name="parameterSign">The set prefix.</param>
            <param name="parent">The parent cypher.</param>
            <returns></returns>
            <example><![CDATA[
            AddOrModify("p", new []{"Person", "Dev"}, new[] {"id", "name"}, "map", "eTag", SetInstanceBehavior.Update)
            Results in:
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p += $map, p.eTag = p.eTag + 1
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateOrUpdate(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Create or update entity.
            For replace use ReplaceOrUpdate
            </summary>
            <param name="variable">The node variable.</param>
            <param name="labels">The labels.</param>
            <param name="parameter">The entity parameter.</param>
            <param name="matchProperties">The match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate("p", new []{"Person", "Dev"}, new[] {"id", "name"}, "map")
            Results in:
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p += $map
            -------------------------------------------------------------------------
            CreateOrUpdate("p", new []{"Person", "Dev"}, new[] {"id", "name"}, "map", "eTag")
            Results in:
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p += $map, p.eTag = p.eTag + 1
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateOrUpdate(System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For replace use ReplaceOrUpdate
            </summary>
            <param name="variable">The node variable.</param>
            <param name="label">The label.</param>
            <param name="parameter">The entity parameter.</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate("p", "Person", "map", "name")
            MERGE (p:Person {name: $map.name})
            SET p += $map
            CreateOrUpdate("p", "Person", "map", "name", "more")
            MERGE (p:Person {name: $map.name, more: $map.more})
            SET p += $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateOrUpdate``1(System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For replace use ReplaceOrUpdate
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The node variable.</param>
            <param name="parameter">The entity parameter.</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate<Person>("p", "map", "name")
            MERGE (p:Person {name: $map.name})
            SET p += $map
            CreateOrUpdate<Person>("p", "map", "name", "more")
            MERGE (p:Person {name: $map.name, more: $map.more})
            SET p += $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateOrUpdate``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Creates the or update.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="matchPropertyExpression">
            The match property expression.
            It will take the lambda variable as the expression variable.
            this variable will serve as the parameter when parameter is null.
            </param>
            <param name="parameter">The entity parameter.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate<Person>(p => p.name, "map")
            MERGE (p:Person {name: $map.name})
            SET p += $map
            ------------------------------------------------
            CreateOrUpdate<Person>(p => p.name, "map", "eTag")
            MERGE (p:Person {name: $map.name})
            SET p += $map, p.eTag = p.eTag + 1
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateOrReplace(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Create or update entity.
            For update use CreateOrUpdate
            </summary>
            <param name="variable">The node variable.</param>
            <param name="labels">The labels.</param>
            <param name="parameter">The entity parameter.</param>
            <param name="matchProperties">The match properties.</param>
            <returns></returns>
            make sure to set unique constraint (on the matching properties),
            otherwise a new node with different concurrency will be created when not match.
            <example><![CDATA[
            CreateOrUpdate("p", new []{"Person", "Dev"}, new[] {"id", "name"}, "map")
            Results in:
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p = $map
            -----------------------------------------------------------------------------
            CreateOrUpdate("p", new []{"Person", "Dev"}, new[] {"id", "name"}, "map", "eTag")
            Results in:
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p = $map, p.eTag = p.eTag + 1
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateOrReplace(System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For update use CreateOrUpdate
            </summary>
            <param name="variable">The node variable.</param>
            <param name="label">The label.</param>
            <param name="parameter">The entity parameter.</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrReplace("p", "Person", "map", "name")
            MERGE (p:Person {name: $map.name})
            ON CREATE SET p = $map
            CreateOrReplace("p", "Person", "map", "name", "more")
            MERGE (p:Person {name: $map.name, more: $map.more})
            SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateOrReplace``1(System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For update use CreateOrUpdate
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The node variable.</param>
            <param name="parameter">The entity parameter.</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrReplace<Person>("p", "map", "name")
            
            MERGE (p:Person {name: $map.name})
                SET p = $map
                
            CreateOrReplace<Person>("p", "map", "name", "more")
            
            MERGE (p:Person {name: $map.name, more: $map.more})
                SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntityMutations#CreateOrReplace``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Creates the or replace.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="matchPropertyExpression">
            The match property expression.
            It will take the lambda variable as the expression variable.
            this variable will serve as the parameter when parameter is null.
            </param>
            <param name="parameter">The entity parameter.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrReplace<Person>(p => p.name, "map")
            Results in:
            MERGE (p:Person {name: $map.name})
            SET p = $map
            ---------------------------------------------------------
            CreateOrReplace<Person>(p => p.name, "map", "eTag")
            Results in:
            MERGE (p:Person {name: $map.name})
            SET p = $map, p.eTag = p.eTag + 1
            ]]></example>
        </member>
        <member name="P:Weknow.CypherBuilder.Entities">
            <summary>
            Nodes mutation by entities (use Unwind pattern).
            </summary>
        </member>
        <member name="M:Weknow.CypherBuilder.AddOrModifyCollection(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.Collections.Generic.IEnumerable{System.String},Weknow.SetInstanceBehavior)">
            <summary>
            Add or Modify entity.
            For replace use ReplaceOrUpdate.
            </summary>
            <param name="collection">Name of the collection.</param>
            <param name="labels">The labels.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The entity parameter.</param>
            <param name="matchProperties">The match properties.</param>
            <param name="onMatchBehavior">The behavior.</param>
            <returns></returns>
            <example><![CDATA[
            AddOrModify("p", new []{"Person", "Dev"}, new[] {"id", "name"}, "map", "eTag", SetInstanceBehavior.Update)
            Results in:
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p += $map, p.eTag = p.eTag + 1
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateNew(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            CREATE by entity
            </summary>
            <param name="collection">The collection.</param>
            <param name="labels">The labels.</param>
            <param name="variable">The node's variable.
            When the parameter is null, it will be used as the parameter.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateNew("items", "n", new [] {"A", "B"}, "map")
            Results in:
            Unwind $items as map
            CREATE (n:A:B map)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateNew(System.String,System.String,System.String,System.String)">
            <summary>
            CREATE by entity
            </summary>
            <param name="collection">The collection.</param>
            <param name="label">The node's label which will be used for the parameter format (variable_label).</param>
            <param name="variable">The node's variable.
            When the parameter is null, it will be used as the parameter.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateNew("n", "FOO")
            Results in:
            CREATE (n:FOO $n_Foo) // Create a node with the given properties.
            --------------------------------------------------------------------------
            CreateNew("n", "FOO", "dev")
            Results in:
            CREATE (n:FOO:DEV $n_Foo) // Create a node with the given properties.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateNew``1(System.String,System.String,System.String)">
            <summary>
            CREATE by entity
            </summary>
            <typeparam name="T">will be used as the node's label. this label will also use for the parameter format (variable_typeof(T).Name).</typeparam>
            <param name="collection">The collection.</param>
            <param name="variable">The node's variable.
            When the parameter is null, it will be used as the parameter.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateNew<Foo>("n")
            Results in:
            CREATE (n:FOO $n_Foo) // Create a node with the given properties.
            --------------------------------------------------------------------------
            CreateNew<Foo>("n", "map")
            Results in:
            CREATE (n:FOO $n_map) // Create a node with the given properties.
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateIfNotExists(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            Create if not exists
            </summary>
            <param name="collection">The collection.</param>
            <param name="labels">The labels.</param>
            <param name="matchProperties">The match properties.</param>
            <param name="variable">The node's variable.
            When the parameter is null, it will be used as the parameter.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists("items", new []{"Person", "Dev"}, new[] {"id", "name"}, "p", "map")
            Results in:
            UNWIND items as map 
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateIfNotExists(System.String,System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create if not exists
            </summary>
            <param name="collection">The collection.</param>
            <param name="label">The label.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists("items", "Person", "p", "map", "id", "name")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {id: $map.id, name: $map.name})
            ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateIfNotExists``1(System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create if not exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists<Person>("items", "p", "map", "id", "name")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {id: $map.id, name: $map.name})
            ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateIfNotExists``1(System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Create if not exists
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <param name="matchPropertyExpression">The match property expression.
            It will take the lambda variable as the expression variable.
            this variable will serve as the parameter when parameter is null.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateIfNotExists<Person>("items", p => p.name, "map")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            ON CREATE SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.AddOrModify(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.Collections.Generic.IEnumerable{System.String},Weknow.SetInstanceBehavior,System.String,Weknow.FluentCypher)">
            <summary>
            Add or Modify entity.
            For replace use ReplaceOrUpdate.
            </summary>
            <param name="collection">The collection.</param>
            <param name="labels">The labels.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The entity parameter.</param>
            <param name="matchProperties">The match properties.</param>
            <param name="onMatchBehavior">The behavior.</param>
            <param name="parameterSign">The set prefix.</param>
            <param name="parent">The parent cypher.</param>
            <returns></returns>
            <example><![CDATA[
            AddOrModify("p", new []{"Person", "Dev"}, new[] {"id", "name"}, "map", "eTag", SetInstanceBehavior.Update)
            Results in:
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p += $map, p.eTag = p.eTag + 1
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateOrUpdate(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            Batch Create or update entities.
            For replace use ReplaceOrUpdate
            </summary>
            <param name="collection">Name of the collection.</param>
            <param name="labels">The labels.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperties">The match properties.</param>
            <returns></returns>
            make sure to set unique constraint (on the matching properties),
            otherwise a new node with different concurrency will be created when not match.
            <example><![CDATA[
            CreateOrUpdate("items", new []{"Person", "Dev"}, new[] {"id", "name"}, "p", "map")
            Results in:
            UNWIND items as map 
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p += $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateOrUpdate(System.String,System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For replace use ReplaceOrUpdate.
            </summary>
            <param name="collection">The collection.</param>
            <param name="label">The label.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate("items", "Person", "p", "map", "name")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            SET p += $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateOrUpdate``1(System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For replace use ReplaceOrUpdate
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate<Person>("items", "p", "map", "name")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            SET p += $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateOrUpdate``1(System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Creates the or update.
            For update use UpdateOrUpdate.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <param name="matchPropertyExpression">The match property expression.
            It will take the lambda variable as the expression variable.
            this variable will serve as the parameter when parameter is null.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrUpdate<Person>("items", p => p.name, "map")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            SET p += $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateOrReplace(System.String,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            Batch Create or update entities.
            For replace use ReplaceOrReplace
            </summary>
            <param name="collection">Name of the collection.</param>
            <param name="labels">The labels.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperties">The match properties.</param>
            <returns></returns>
            make sure to set unique constraint (on the matching properties),
            otherwise a new node with different concurrency will be created when not match.
            <example><![CDATA[
            CreateOrReplace("items", new []{"Person", "Dev"}, new[] {"id", "name"}, "p", "map")
            Results in:
            UNWIND items as map 
            MERGE (p:Person:Dev {id: $map.id, name: $map.name})
            SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateOrReplace(System.String,System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For replace use ReplaceOrReplace.
            </summary>
            <param name="collection">The collection.</param>
            <param name="label">The label.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrReplace("items", "Person", "p", "map", "name")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateOrReplace``1(System.String,System.String,System.String,System.String,System.String[])">
            <summary>
            Create or update entity.
            For replace use ReplaceOrReplace
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <param name="variable">The node variable.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <param name="matchProperty">The match property.</param>
            <param name="moreMatchProperties">The more match properties.</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrReplace<Person>("items", "p", "map", "name")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            SET p = $map
            ]]></example>
        </member>
        <member name="M:Weknow.CypherBuilder.Weknow#ICypherEntitiesMutations#CreateOrReplace``1(System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String)">
            <summary>
            Creates the or update.
            For update use ReplaceOrReplace.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection">The collection.</param>
            <param name="matchPropertyExpression">The match property expression.
            It will take the lambda variable as the expression variable.
            this variable will serve as the parameter when parameter is null.</param>
            <param name="parameter">The parameter (if missing, use the variable instead).</param>
            <returns></returns>
            <example><![CDATA[
            CreateOrReplace<Person>("items", p => p.name, "map")
            Results in:
            UNWIND items as map 
            MERGE (p:Person {name: $map.name})
            SET p = $map
            ]]></example>
        </member>
        <member name="T:Weknow.CypherFactory">
            <summary>
            Cypher Factories.
            </summary>
            <summary>
            Cypher Factories.
            </summary>
        </member>
        <member name="T:Weknow.CypherFactory.A">
            <summary>
            Cypher Aggregate Function
            </summary>
        </member>
        <member name="T:Weknow.CypherFactory.Aggregate">
            <summary>
            Cypher Aggregate Function
            </summary>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.Count">
            <summary>
            List from the values, ignores null.
            </summary>
            <returns></returns>
            <example>count(*)</example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.Count(System.String)">
            <summary>
            Count The number of non-null values..
            </summary>
            <param name="variable">The variable.</param>
            <returns></returns>
            <example><![CDATA[count(variable)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.CountDistinct">
            <summary>
            List from the values, ignores null,
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <returns></returns>
            <example><![CDATA[count(*)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.CountDistinct(System.String)">
            <summary>
            Count The number of non-null values,
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="variable">The variable.</param>
            <returns></returns>
            <example><![CDATA[count(variable)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.Collect(System.String)">
            <summary>
            Collect list from the values, ignores null.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[collect(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.Collect(System.String,System.String)">
            <summary>
            Collect list from the values, ignores null.
            </summary>
            <param name="variable">The variable.</param>
            <param name="asName">As name.</param>
            <returns></returns>
            <example><![CDATA[collect(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.Collect``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Collect list from the values, ignores null.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            Collect<Foo>(f => f.Name)
            collect(f.Name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.CollectDistinct(System.String)">
            <summary>
            CollectDistinct list from the values, ignores null,
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[collect(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.CollectDistinct``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            CollectDistinct list from the values, ignores null,
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            CollectDistinct<Foo>(f => f.Name)
            collect(f.Name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.Sum(System.String)">
            <summary>
            Sum numerical values. Similar functions are avg(), min(), max().
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[sum(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.Sum``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Sum numerical values. Similar functions are avg(), min(), max().
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            Sum<Foo>(f => f.Name)
            sum(f.Name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.SumDistinct(System.String)">
            <summary>
            SumDistinct numerical values. Similar functions are avg(), min(), max(),
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[sum(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.SumDistinct``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            SumDistinct numerical values. Similar functions are avg(), min(), max(),
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            SumDistinct<Foo>(f => f.Name)
            sum(f.Name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.Avg(System.String)">
            <summary>
            Average numerical values. Similar functions are sum(), min(), max().
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[avg(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.Avg``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Average numerical values. Similar functions are sum(), min(), max().
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            Avg<Foo>(f => f.Name)
            avg(f.Name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.AvgDistinct(System.String)">
            <summary>
            Average numerical values. Similar functions are sum(), min(), max(),
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[avg(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.AvgDistinct``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Average numerical values. Similar functions are sum(), min(), max(),
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            AvgDistinct<Foo>(f => f.Name)
            avg(f.Name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.Min(System.String)">
            <summary>
            Min numerical values. Similar functions are avg(), sum(), max().
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[min(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.Min``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Min numerical values. Similar functions are avg(), min(), max().
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            Min<Foo>(f => f.Name)
            min(f.Name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.MinDistinct(System.String)">
            <summary>
            MinDistinct numerical values. Similar functions are avg(), sum(), max(),
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[min(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.MinDistinct``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            MinDistinct numerical values. Similar functions are avg(), min(), max(),
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            MinDistinct<Foo>(f => f.Name)
            min(f.Name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.Max(System.String)">
            <summary>
            Max numerical values. Similar functions are avg(), sum(), min().
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[max(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.Max``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Max numerical values. Similar functions are avg(), max(), min().
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            Max<Foo>(f => f.Name)
            max(f.Name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.MaxDistinct(System.String)">
            <summary>
            Maximums the distinct.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.MaxDistinct``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            MaxDistinct numerical values. Similar functions are avg(), maxDistinct(), min(),
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            MaxDistinct<Foo>(f => f.Name)
            maxDistinct(f.Name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.PercentileDisc(System.String,System.Double)">
            <summary>
            Discrete percentile. Continuous percentile is percentileCont().
            The percentile argument is from 0.0 to 1.0.
            </summary>
            <param name="expression">The expression.</param>
            <param name="percentile">he percentile argument is from 0.0 to 1.0.</param>
            <returns></returns>
            <example><![CDATA[percentileDisc(n.property, $percentile)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.PercentileDisc``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Double)">
            <summary>
            Discrete percentile. Continuous percentile is percentileCont().
            The percentile argument is from 0.0 to 1.0.
            </summary>
            <param name="expression">The expression.</param>
            <param name="percentile">he percentile argument is from 0.0 to 1.0.</param>
            <returns></returns>
            <example><![CDATA[
            PercentileDisc<Foo>(f => f.Name)
            percentileDisc(f.Name, 0.8)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.PercentileDiscDistinct(System.String,System.Double)">
            <summary>
            Discrete percentile. Continuous percentile is percentileCont().
            The percentile argument is from 0.0 to 1.0.
            </summary>
            <param name="expression">The expression.</param>
            <param name="percentile">he percentile argument is from 0.0 to 1.0.</param>
            <returns></returns>
            <example><![CDATA[percentileDisc(n.property, $percentile)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.PercentileDiscDistinct``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Double)">
            <summary>
            Discrete percentile. Continuous percentile is percentileCont().
            The percentile argument is from 0.0 to 1.0.
            </summary>
            <param name="expression">The expression.</param>
            <param name="percentile">he percentile argument is from 0.0 to 1.0.</param>
            <returns></returns>
            <example><![CDATA[
            PercentileDiscDistinct<Foo>(f => f.Name)
            percentileDisc(f.Name, 0.8)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.PercentileCount(System.String,System.Double)">
            <summary>
            percentileCont() returns the percentile 
            of the given value over a group, with a percentile from 0.0 to 1.0. 
            It uses a linear interpolation method, 
            calculating a weighted average between two values 
            if the desired percentile lies between them. 
            For nearest values using a rounding method, see percentileDisc.
            </summary>
            <param name="expression">The expression.</param>
            <param name="percentile">he percentile argument is from 0.0 to 1.0.</param>
            <returns></returns>
            <example><![CDATA[percentileCont(expression, percentile)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.PercentileCount``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Double)">
            <summary>
            percentileCont() returns the percentile 
            of the given value over a group, with a percentile from 0.0 to 1.0. 
            It uses a linear interpolation method, 
            calculating a weighted average between two values 
            if the desired percentile lies between them. 
            For nearest values using a rounding method, see percentileDisc.
            The percentile argument is from 0.0 to 1.0.
            </summary>
            <param name="expression">The expression.</param>
            <param name="percentile">he percentile argument is from 0.0 to 1.0.</param>
            <returns></returns>
            <example><![CDATA[
            PercentileCont<Foo>(f => f.Name, 0.8)
            percentileCont(f.Name, 0.8)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.PercentileCountDistinct(System.String,System.Double)">
            <summary>
            percentileCont() returns the percentile 
            of the given value over a group, with a percentile from 0.0 to 1.0. 
            It uses a linear interpolation method, 
            calculating a weighted average between two values 
            if the desired percentile lies between them. 
            For nearest values using a rounding method, see percentileDisc.
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <param name="percentile">he percentile argument is from 0.0 to 1.0.</param>
            <returns></returns>
            <example><![CDATA[percentileCont(expression, percentile)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.PercentileCountDistinct``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.Double)">
            <summary>
            percentileCont() returns the percentile 
            of the given value over a group, with a percentile from 0.0 to 1.0. 
            It uses a linear interpolation method, 
            calculating a weighted average between two values 
            if the desired percentile lies between them. 
            For nearest values using a rounding method, see percentileDisc.
            The percentile argument is from 0.0 to 1.0.
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <param name="percentile">he percentile argument is from 0.0 to 1.0.</param>
            <returns></returns>
            <example><![CDATA[
            PercentileCont<Foo>(f => f.Name, 0.8)
            percentileCont(f.Name, 0.8)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.StDev(System.String)">
            <summary>
            Standard deviation for a sample of a population. For an entire population use stDevP().
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[stDev(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.StDev``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Standard deviation for a sample of a population. For an entire population use stDevP().
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            StDev<Foo>(f => f.Name)
            stDev(f.Name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.StDevDistinct(System.String)">
            <summary>
            Standard deviation for a sample of a population. For an entire population use stDevP().
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[stDev(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.StDevDistinct``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Standard deviation for a sample of a population. For an entire population use stDevP().
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            StDevDistinct<Foo>(f => f.Name)
            stDev(f.Name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.StDevP(System.String)">
            <summary>
            stDevP() returns the standard deviation for the given value over a group. 
            It uses a standard two-pass method, with N as the denominator, 
            and should be used when calculating the standard deviation for an entire population. 
            When the standard variation of only a sample of the population is being calculated, 
            stDev should be used.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[stDevP(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.StDevP``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            stDevP() returns the standard deviation for the given value over a group. 
            It uses a standard two-pass method, with N as the denominator, 
            and should be used when calculating the standard deviation for an entire population. 
            When the standard variation of only a sample of the population is being calculated, 
            stDev should be used.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            StDevP<Foo>(f => f.Name)
            stDevP(f.Name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.StDevPDistinct(System.String)">
            <summary>
            stDevP() returns the standard deviation for the given value over a group. 
            It uses a standard two-pass method, with N as the denominator, 
            and should be used when calculating the standard deviation for an entire population. 
            When the standard variation of only a sample of the population is being calculated, 
            stDev should be used.
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[stDevP(n.property)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Aggregate.StDevPDistinct``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            stDevP() returns the standard deviation for the given value over a group. 
            It uses a standard two-pass method, with N as the denominator, 
            and should be used when calculating the standard deviation for an entire population. 
            When the standard variation of only a sample of the population is being calculated, 
            stDev should be used.
            also take the DISTINCT operator, which removes duplicates from the values.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            StDevPDistinct<Foo>(f => f.Name)
            stDevP(f.Name)
            ]]></example>
        </member>
        <member name="T:Weknow.CypherFactory.F">
            <summary>
            Cypher Functions
            </summary>
        </member>
        <member name="T:Weknow.CypherFactory.Function">
            <summary>
            Cypher Functions
            </summary>
        </member>
        <member name="M:Weknow.CypherFactory.Function.Labels(System.String)">
            <summary>
            Labels of the node..
            </summary>
            <param name="nodeVariable">The node variable.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Function.Coalesce(System.String,System.String,System.String[])">
            <summary>
            Coalesces the specified first.
            </summary>
            <param name="first">The first.</param>
            <param name="second">The second.</param>
            <param name="more">The more.</param>
            <returns></returns>
            <example><![CDATA[coalesce(n.property, $defaultValue)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Function.Coalesce(System.Func{Weknow.FluentCypher,Weknow.FluentCypher})">
            <summary>
            Coalesces The first non-null expression.
            </summary>
            <param name="contentExpression"></param>
            <returns></returns>
            <example><![CDATA[coalesce(n.property, $defaultValue)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Function.Coalesce(Weknow.FluentCypher)">
            <summary>
            Coalesces The first non-null expression.
            </summary>
            <param name="content">The delegated.</param>
            <returns></returns>
            <example><![CDATA[coalesce(n.property, $defaultValue)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Function.Timestamp">
            <summary>
            Milliseconds since midnight, January 1, 1970 UTC.
            </summary>
            <returns></returns>
            <example><![CDATA[timestamp()]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Function.Id(System.String)">
            <summary>
            The internal id of the relationship or node.
            </summary>
            <param name="nodeOrRelationship">The node or relationship.</param>
            <returns></returns>
            <example><![CDATA[id(nodeOrRelationship)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Function.ToInteger(System.String)">
            <summary>
            Converts the given input into an integer if possible; otherwise it returns null.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[toInteger($expr)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Function.ToFloat(System.String)">
            <summary>
            Converts the given input into a floating point number if possible; otherwise it returns null.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[toFloat($expr)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Function.ToBoolean(System.String)">
            <summary>
            Converts the given input into a boolean if possible; otherwise it returns null.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[toFloat($expr)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Function.Keys(System.String)">
            <summary>
            Returns a list of string representations for the property names of a node, relationship, or map.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[keys($expr)]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Function.Properties(System.String)">
            <summary>
            Returns a map containing all the properties of a node or relationship.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[properties($expr)]]></example>
        </member>
        <member name="T:Weknow.CypherFactory.I">
            <summary>
            Cypher Indices and Constraints
            </summary>
        </member>
        <member name="T:Weknow.CypherFactory.Indices">
            <summary>
            Cypher Aggregate Function
            </summary>
        </member>
        <member name="M:Weknow.CypherFactory.Indices.CreateIndex(System.String,System.String,System.String[])">
            <summary>
            Create an index on label and property.
            if the compositePropertyNames isn't empty it
            Create a composite index on the label and the all properties names (propertyName + compositePropertyNames).
            </summary>
            <param name="label">The label.</param>
            <param name="propertyName">Name of the property.</param>
            <param name="compositePropertyNames">The composite property names.</param>
            <returns></returns>
            <example><![CDATA[
            CREATE INDEX ON :Person(name)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Indices.DropIndex(System.String,System.String,System.String[])">
            <summary>
            Drop the index on the label and properties..
            </summary>
            <param name="label">The label.</param>
            <param name="propertyName">Name of the property.</param>
            <param name="compositePropertyNames">The composite property names.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Indices.CreateUniqueConstraint(System.String,System.String,System.String,Weknow.CypherNamingConvention)">
            <summary>
            Create a unique property constraint on the label and property.
            If any other node with that label is updated or
            created with a name that already exists,
            the write operation will fail.
            This constraint will create an accompanying index.
            </summary>
            <param name="label">The label.</param>
            <param name="propertyName">Name of the property.</param>
            <param name="variable">The variable.</param>
            <param name="convention">The convention.</param>
            <returns></returns>
            <example><![CDATA[
            I.CreateUniqueConstraint("Foo", "Name")
            Results in:
            CREATE CONSTRAINT ON (n:{Foo}) ASSERT n.Name IS UNIQUE
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Indices.CreateUniqueConstraint``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},Weknow.CypherNamingConvention)">
            <summary>
            Create a unique property constraint on the label and property.
            If any other node with that label is updated or
            created with a name that already exists,
            the write operation will fail.
            This constraint will create an accompanying index.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression">The expression.</param>
            <param name="convention">The convention.</param>
            <returns></returns>
            <example><![CDATA[
            I.CreateUniqueConstraint<Foo>(f => f.Name)
            Results in:
            CREATE CONSTRAINT ON (f:{Foo}) ASSERT f.Name IS UNIQUE
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Indices.DropUniqueConstraint(System.String,System.String,System.String,Weknow.CypherNamingConvention)">
            <summary>
            Drop the unique constraint and index on the label and property.
            </summary>
            <param name="label">The label.</param>
            <param name="propertyName">Name of the property.</param>
            <param name="variable">The variable.</param>
            <param name="convention">The convention.</param>
            <returns></returns>
            <example><![CDATA[
            I.CreateUniqueConstraint("Foo", "Name")
            Results in:
            CREATE CONSTRAINT ON (n:{Foo}) ASSERT n.Name IS UNIQUE
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Indices.DropUniqueConstraint``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},Weknow.CypherNamingConvention)">
            <summary>
            Drop the unique constraint and index on the label and property.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression">The expression.</param>
            <param name="convention">The convention.</param>
            <returns></returns>
            <example><![CDATA[
            I.CreateUniqueConstraint<Foo>(f => f.Name)
            Results in:
            DROP CONSTRAINT ON (f:{Foo}) ASSERT f.Name IS UNIQUE
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Indices.CreateExistsConstraint(System.String,System.String)">
            <summary>
            Create a node property existence constraint on the label and property. 
            If a node with that label is created without a name, 
            or if the name property is removed 
            from an existing node with the Person label, 
            the write operation will fail.
            </summary>
            <param name="label">The label.</param>
            <param name="propertyName">Name of the property.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Indices.DropExistsConstraint(System.String,System.String)">
            <summary>
            Drop the node property existence constraint on the label and property.
            </summary>
            <param name="label">The label.</param>
            <param name="propertyName">Name of the property.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Indices.CreateNodeKeyConstraint(System.String,System.String,System.String,System.String[])">
            <summary>
            Create a Node Key constraint on the Person and properties.
            If a node with that label is created without both one of the properties or 
            if the combination of the properties is not unique, the write operation will fail.
            </summary>
            <param name="label">The label.</param>
            <param name="propertyName1">The property name1.</param>
            <param name="propertyName2">The property name2.</param>
            <param name="morePropertyNames">The more property names.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Indices.DropNodeKeyConstraint(System.String,System.String,System.String,System.String[])">
            <summary>
            Drop the Node Key constraint on the label and properties.
            </summary>
            <param name="label">The label.</param>
            <param name="propertyName1">The property name1.</param>
            <param name="propertyName2">The property name2.</param>
            <param name="morePropertyNames">The more property names.</param>
            <returns></returns>
        </member>
        <member name="T:Weknow.CypherFactory.Collections">
            <summary>
            Cypher List Expressions
            </summary>
        </member>
        <member name="T:Weknow.CypherFactory.L">
            <summary>
            Cypher List Expressions
            </summary>
        </member>
        <member name="T:Weknow.CypherFactory.Lists">
            <summary>
            Cypher List Expressions
            </summary>
        </member>
        <member name="M:Weknow.CypherFactory.Lists.Size(System.String)">
            <summary>
            Number of elements in the list.
            </summary>
            <param name="list">The list.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Lists.Reverse(System.String)">
            <summary>
            Reverse the order of the elements in the list.
            </summary>
            <param name="list">The list.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Lists.Head(System.String)">
            <summary>
            head() returns the first.
            return null for an empty list.
            </summary>
            <param name="list">The list.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Lists.Last(System.String)">
            <summary>
            last() the last element of the list.
            return null for an empty list.
            </summary>
            <param name="list">The list.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Lists.Tail(System.String)">
            <summary>
            tail() returns all but the first element.
            return null for an empty list.
            </summary>
            <param name="list">The list.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Lists.Reduce(System.String)">
            <summary>
            Evaluate expression for each element in the list, accumulate the results.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            reduce(s = "", x IN list | s + x.prop)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Lists.Reduce(System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Evaluate expression for each element in the list, accumulate the results.
            </summary>
            <param name="accumulatorVariable">The variable of the accumulator.</param>
            <param name="initValue">The initialize value.</param>
            <param name="list">The list.</param>
            <param name="item">The item.</param>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            Reduce("s", "''", "list", "x", "s + x.prop")
            reduce(s = "", x IN list | s + x.prop)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Lists.Reduce(System.Func{Weknow.FluentCypher,Weknow.FluentCypher})">
            <summary>
            Evaluate expression for each element in the list, accumulate the results.
            </summary>
            <param name="contentExpression"></param>
            <returns></returns>
            <example><![CDATA[
            reduce(s = "", x IN list | s + x.prop)
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Lists.Reduce(Weknow.FluentCypher)">
            <summary>
            Evaluate expression for each element in the list, accumulate the results.
            </summary>
            <param name="content">The delegated.</param>
            <returns></returns>
            <example><![CDATA[
            reduce(s = "", x IN list | s + x.prop)
            ]]></example>
        </member>
        <member name="T:Weknow.CypherFactory.M">
            <summary>
            Cypher Mathematical Functions 
            </summary>
        </member>
        <member name="T:Weknow.CypherFactory.Mathematic">
            <summary>
            Cypher Mathematical Functions 
            </summary>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Abs(System.String)">
            <summary>
            The absolute value.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Rand">
            <summary>
            Returns a random number
            in the range from 0 (inclusive) to 1 (exclusive), [0,1).
            Returns a new value for each call.
            Also useful for selecting a subset or random ordering.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Round(System.String)">
            <summary>
            Round to the nearest integer; 
            ceil() and floor() find the next integer up or down.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Sqrt(System.String)">
            <summary>
            The square root.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Sign(System.String)">
            <summary>
            0 if zero, -1 if negative, 1 if positive.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Sin(System.String)">
            <summary>
            Trigonometric functions also include 
            cos(), tan(), cot(), asin(), acos(), atan(), atan2(), 
            and haversin(). All arguments for the trigonometric functions 
            should be in radians, if not otherwise specified.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Cos(System.String)">
            <summary>
            Trigonometric functions also include 
            sin(), cos(), tan(), cot(), asin(), acos(), atan(), atan2(), 
            and haversin(). All arguments for the trigonometric functions 
            should be in radians, if not otherwise specified.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Tan(System.String)">
            <summary>
            Trigonometric functions also include 
            sin(), cos(), tan(), cot(), asin(), acos(), atan(), atan2(), 
            and haversin(). All arguments for the trigonometric functions 
            should be in radians, if not otherwise specified.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Cot(System.String)">
            <summary>
            Trigonometric functions also include 
            sin(), cos(), tan(), cot(), asin(), acos(), atan(), atan2(), 
            and haversin(). All arguments for the trigonometric functions 
            should be in radians, if not otherwise specified.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Asin(System.String)">
            <summary>
            Trigonometric functions also include 
            sin(), cos(), tan(), cot(), asin(), acos(), atan(), atan2(), 
            and haversin(). All arguments for the trigonometric functions 
            should be in radians, if not otherwise specified.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Acos(System.String)">
            <summary>
            Trigonometric functions also include 
            sin(), cos(), tan(), cot(), asin(), acos(), atan(), atan2(), 
            and haversin(). All arguments for the trigonometric functions 
            should be in radians, if not otherwise specified.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Atan(System.String)">
            <summary>
            Trigonometric functions also include 
            sin(), cos(), tan(), cot(), asin(), acos(), atan(), atan2(), 
            and haversin(). All arguments for the trigonometric functions 
            should be in radians, if not otherwise specified.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Atan2(System.String)">
            <summary>
            Trigonometric functions also include 
            sin(), cos(), tan(), cot(), asin(), acos(), atan(), atan2(), 
            and haversin(). All arguments for the trigonometric functions 
            should be in radians, if not otherwise specified.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Haversin(System.String)">
            <summary>
            Trigonometric functions also include 
            sin(), cos(), tan(), cot(), asin(), acos(), atan(), atan2(), 
            and haversin(). All arguments for the trigonometric functions 
            should be in radians, if not otherwise specified.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Radians(System.String)">
            <summary>
            Converts radians into degrees; use radians() for the reverse, and pi() for .
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Pi">
            <summary>
            Converts radians into degrees; use radians() for the reverse, and pi() for .
            </summary>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Log10(System.String)">
            <summary>
            Logarithm base 10, natural logarithm, e to the power of the parameter, and the value of e.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Log(System.String)">
            <summary>
            Logarithm base 10, natural logarithm, e to the power of the parameter, and the value of e.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.Exp(System.String)">
            <summary>
            Logarithm base 10, natural logarithm, e to the power of the parameter, and the value of e.
            </summary>
            <param name="expression">The expression.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Mathematic.E">
            <summary>
            Converts radians into degrees; use radians() for the reverse, and pi() for .
            </summary>
            <returns></returns>
        </member>
        <member name="T:Weknow.CypherFactory.P">
            <summary>
            Properties factories
            </summary>
        </member>
        <member name="T:Weknow.CypherFactory.Properties">
            <summary>
            Properties factories
            </summary>
        </member>
        <member name="M:Weknow.CypherFactory.Properties.Create(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String)">
            <summary>
            Compose properties phrase.
            </summary>
            <param name="propNames">The property names.</param>
            <param name="parameterPrefix">Variable prefix.</param>
            <param name="parameterSeparator">The variable prefix separator.</param>
            <param name="parameterSign">The parameter sign.</param>
            <returns></returns>
            <example><![CDATA[
            -----------------------------------------------
            P.Create(new ["Name", "Id"])
            Results in:
            { Name: $Name, Id: $Id}
            -----------------------------------------------
            P.Create(new ["Name", "Id"], "prefix")
            Results in:
            { Name: $prefix_Name, Id: $prefix_Id}
            -----------------------------------------------
            P.Create(new ["Name", "Id"], "prefix", ".")
            Results in:
            { Name: $prefix.Name, Id: $prefix.Id}
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Properties.Create(System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            Compose properties phrase.
            </summary>
            <param name="parameterPrefix">Variable prefix.</param>
            <param name="parameterSeparator">The variable prefix separator.</param>
            <param name="propNames">The property names.</param>
            <returns></returns>
            <example><![CDATA[
            -----------------------------------------------
            P.Create(new ["Name", "Id"])
            Results in:
            { Name: $Name, Id: $Id}
            -----------------------------------------------
            P.Create(new ["Name", "Id"], "prefix")
            Results in:
            { Name: $prefix_Name, Id: $prefix_Id}
            -----------------------------------------------
            P.Create(new ["Name", "Id"], "prefix", ".")
            Results in:
            { Name: $prefix.Name, Id: $prefix.Id}
            ]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Properties.Create(System.String,System.String[])">
            <summary>
            Compose properties phrase.
            </summary>
            <param name="name">The name.</param>
            <param name="moreNames">The more names.</param>
            <returns></returns>
            <example><![CDATA[{ Name: $Name, Id: $Id}]]></example>
        </member>
        <member name="M:Weknow.CypherFactory.Properties.Create``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}}[])">
            <summary>
            Compose properties phrase from a type expression.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="propExpressions">The property expressions.</param>
            <example><![CDATA[
            ComposeProps<Foo>(f => f.Name, f => f.Id)
            { Name: $Name, Id: $Id}
            ]]></example>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Properties.CreateByConvention``1(System.Func{System.String,System.Boolean})">
            <summary>
            Compose properties phrase by convention.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filter">The filter.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Properties.CreateByConvention``1(System.String,System.Func{System.String,System.Boolean})">
            <summary>
            Compose properties phrase by convention.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="filter">The filter.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Properties.CreateAll``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}}[])">
            <summary>
            Compose properties phrase by reflection with exclude option.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="excludes">The excludes.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Properties.CreateAll``1(System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Object}}[])">
            <summary>
            Compose properties phrase by reflection with exclude option.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="excludes">The excludes.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Properties.LineSeparatorStrategy(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Separators the strategy.
            </summary>
            <param name="propNames">The property names.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.CypherFactory.Properties.SetSeparatorStrategy(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Separators the strategy.
            </summary>
            <param name="propNames">The property names.</param>
            <returns></returns>
        </member>
        <member name="T:Weknow.FluentCypher">
            <summary>
            Fluent Cypher
            </summary>
        </member>
        <member name="M:Weknow.FluentCypher.#ctor">
            <summary>
            Prevents a default instance of the <see cref="T:Weknow.FluentCypher" /> class from being created.
            </summary>
        </member>
        <member name="M:Weknow.FluentCypher.#ctor(Weknow.CypherConfig)">
            <summary>
            Initialize constructor
            </summary>
            <param name="config">The configuration.</param>
        </member>
        <member name="M:Weknow.FluentCypher.#ctor(Weknow.FluentCypher,System.String,Weknow.CypherPhrase,System.String,System.Collections.Generic.IEnumerable{Weknow.FluentCypher},System.String,Weknow.CypherConfig)">
            <summary>
            Initializes a new instance of the <see cref="T:Weknow.FluentCypher" /> class.
            </summary>
            <param name="copyFrom">The copy from.</param>
            <param name="cypher">The cypher.</param>
            <param name="phrase">The phrase.</param>
            <param name="cypherClose">The cypher close.</param>
            <param name="children">The delegated.</param>
            <param name="childrenSeparator">The children separator  (space if empty).</param>
            <param name="config">The configuration.</param>
        </member>
        <member name="P:Weknow.FluentCypher._config">
            <summary>
            Gets the configuration.
            </summary>
        </member>
        <member name="P:Weknow.FluentCypher.Config">
            <summary>
            Gets the configuration.
            </summary>
        </member>
        <member name="M:Weknow.FluentCypher.Add(System.String)">
            <summary>
            Adds a statement (any valid cypher query).
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.FluentCypher.Match(System.String)">
            <summary>
            Create MATCH phrase
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MATCH (n:Person)-[:KNOWS]->(m:Person)
            MATCH (n)-->(m)
            MATCH (n {name: 'Alice'})-->(m)
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.OptionalMatch(System.String)">
            <summary>
            Create OPTIONAL MATCH phrase
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            OPTIONAL MATCH (n)-[r]->(m)
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Where(System.String)">
            <summary>
            Create WHERE phrase
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            WHERE n.property <> $value
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Where(System.String,System.String,System.String[])">
            <summary>
            Create WHERE phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="name">The name.</param>
            <param name="moreNames">The more names.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.FluentCypher.Where(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Create WHERE phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="moreNames">The more names.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.FluentCypher.Where``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String,System.String,System.String)">
            <summary>
            Create WHERE phrase, generated by expression
            </summary>
            <typeparam name="T"></typeparam>
            <param name="propExpression">The property expression.</param>
            <param name="parameterPrefix">The parameter prefix.</param>
            <param name="parameterSign">The parameter sign.</param>
            <param name="compareSign">The compare sign.</param>
            <returns></returns>
            <example><![CDATA[
            Where ((User user) => user.Id))
            Result with
            WHERE user.Id = $Id
            Where ((User user) => user.Id), ">")
            Result with
            WHERE user.Id > $Id AND
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Create(System.String)">
            <summary>
            Create CREATE phrase
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            CREATE (n {name: $value}) // Create a node with the given properties.
            CREATE (n $map) // Create a node with the given properties.
            CREATE (n) SET n = properties // Create nodes with the given properties.
            CREATE (n)-[r:KNOWS]->(m) // Create a relationship with the given type and direction; bind a variable to it.
            CREATE (n)-[:LOVES {since: $value}]->(m) // Create a relationship with the given type, direction, and properties.
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Merge(System.String)">
            <summary>
            Create MERGE phrase.
            Match a pattern or create it if it does not exist. 
            Use ON CREATE and ON MATCH for conditional updates.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET 
              n.counter = coalesce(n.counter, 0) + 1,
              n.accessTime = timestamp()
            ------------------------------------------  
            MATCH (a:Person {name: $value1}),
                  (b:Person {name: $value2})
            MERGE(a)-[r: LOVES]->(b)
            ------------------------------------------
            MATCH (a:Person {name: $value1})
            MERGE (a)-[r: KNOWS]->(b:Person {name: $value3})
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.OnCreate">
            <summary>
            Compose ON CREATE phrase.
            Match a pattern or create it if it does not exist. 
            Use ON CREATE and ON MATCH for conditional updates.
            </summary>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            
              n.counter = coalesce(n.counter, 0) + 1,
              n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.OnCreate(System.String)">
            <summary>
            Compose ON CREATE phrase.
            Match a pattern or create it if it does not exist.
            Use ON CREATE and ON MATCH for conditional updates.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            n.counter = coalesce(n.counter, 0) + 1,
            n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.OnMatch">
            <summary>
            Compose ON MATCH phrase
            Match a pattern or create it if it does not exist. 
            Use ON CREATE and ON MATCH for conditional updates.
            </summary>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            
              n.counter = coalesce(n.counter, 0) + 1,
              n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.OnMatch(System.String)">
            <summary>
            Compose ON MATCH phrase
            Match a pattern or create it if it does not exist.
            Use ON CREATE and ON MATCH for conditional updates.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            n.counter = coalesce(n.counter, 0) + 1,
            n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.OnMatchSet(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Compose ON MATCH SET phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="propNames">The property names.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            n.counter = coalesce(n.counter, 0) + 1,
            n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.OnMatchSet(System.String,System.String,System.String[])">
            <summary>
            Compose ON MATCH SET phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="name">The name.</param>
            <param name="moreNames">The more names.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            n.counter = coalesce(n.counter, 0) + 1,
            n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.OnMatchSet``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Compose ON MATCH SET phrase from a type expression.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="propExpression">The property expression.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            n.counter = coalesce(n.counter, 0) + 1,
            n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.OnMatchSetByConvention``1(System.String,System.Func{System.String,System.Boolean})">
            <summary>
            Compose ON MATCH SET phrase by convention.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="filter">The filter.</param>
            <returns></returns>
            <example><![CDATA[
            MERGE (n:Person {name: $value})
            ON CREATE SET n.created = timestamp()
            ON MATCH SET
            n.counter = coalesce(n.counter, 0) + 1,
            n.accessTime = timestamp()
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Set(System.String)">
            <summary>
            Compose SET phrase
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            SET n.property1 = $value1, n.property2 = $value2 // Update or create a property.
            SET n = $map // Update or create a property.
            SET n += $map // Add and update properties, while keeping existing ones.
            SET n:Person // Adds a label Person to a node.
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Set(System.String,System.Collections.Generic.IEnumerable{System.String},System.String,System.String)">
            <summary>
            Compose SET phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="propNames">The property names.</param>
            <param name="parameterPrefix">The parameter prefix.</param>
            <param name="parameterSign">The parameter sign.</param>
            <returns></returns>
            <example><![CDATA[
            Set("n", new [] { nameof(Foo.Name), nameof(Bar.Id)})
            SET n.Name = $Name, n.Id = $Id // Update or create a property.
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Set(System.String,System.String,System.String[])">
            <summary>
            Compose SET phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="name">The name.</param>
            <param name="moreNames">The more names.</param>
            <returns></returns>
            <example><![CDATA[
            Set("n", nameof(Foo.Name), nameof(Bar.Id))
            SET n.Name = $Name, n.Id = $Id // Update or create a property.
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Set``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}},System.String,System.String)">
            <summary>
            Compose SET phrase from a type expression.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="propExpression">The property expression.</param>
            <param name="parameterPrefix">The parameter prefix.</param>
            <param name="parameterSign">The parameter sign.</param>
            <returns></returns>
            <example><![CDATA[
            Set((User user) => user.Name)
            SET user.Name = $Name // Update or create a property.
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.SetEntity(System.String,System.String,System.String,Weknow.SetInstanceBehavior)">
            <summary>
            Sets the entity.
            </summary>
            <param name="variable">The variable.</param>
            <param name="paramName">Name of the parameter.</param>
            <param name="parameterPrefix">The parameter prefix.</param>
            <param name="behavior">The behavior.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.FluentCypher.SetEntity(System.String,System.String,Weknow.SetInstanceBehavior)">
            <summary>
            Set instance. 
            Behaviors:
            Replace: This will remove any existing properties.
            Update: update properties, while keeping existing ones.
            </summary>
            <param name="variable">The variable.</param>
            <param name="paramName"></param>
            <param name="behavior"></param>
            <returns></returns>
            <example><![CDATA[
            Set("u", "entity")
            SET u = $u_entity
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.SetEntity``1(System.String,Weknow.SetInstanceBehavior)">
            <summary>
            Set instance.
            Behaviors:
            Replace: This will remove any existing properties.
            Update: update properties, while keeping existing ones.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="behavior">The behavior.</param>
            <returns></returns>
            <example><![CDATA[
            Set<UserEntity>("u")
            SET u = $u_UserEntity
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.SetEntity``1(System.String,System.String,Weknow.SetInstanceBehavior)">
            <summary>
            Set instance.
            Behaviors:
            Replace: This will remove any existing properties.
            Update: update properties, while keeping existing ones.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="parameterPrefix">The parameter prefix.</param>
            <param name="behavior">The behavior.</param>
            <returns></returns>
            <example><![CDATA[
            Set<UserEntity>("u")
            SET u = $UserEntity
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.SetAll``1(System.String,System.Linq.Expressions.Expression{System.Func{``0,System.Object}}[])">
            <summary>
            Set all properties (optional with excludes).
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="excludes">The excludes.</param>
            <returns></returns>
            <example><![CDATA[
            Set<UserEntity>("u")
            SET u = $UserEntity
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.SetByConvention``1(System.String,System.Func{System.String,System.Boolean})">
            <summary>
            Compose SET phrase by convention.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="filter">The filter.</param>
            <returns></returns>
            <example><![CDATA[
            Set((User user) =&gt; user.Name.StartWith("Name"))
            SET user.FirstName = $FirstName, usr.LastName = $LastName // Update or create a property.
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.SetLabel(System.String,System.String)">
            <summary>
            Sets the label.
            </summary>
            <param name="variable">The variable.</param>
            <param name="label">The label.</param>
            <returns></returns>
            <example><![CDATA[
            SET n:Person
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Remove(System.String)">
            <summary>
            Create REMOVE phrase,
            Remove the label from the node or property.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            REMOVE n:Person // Remove a label from n.
            REMOVE n.property // Remove a property.
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Delete(System.String)">
            <summary>
            Create DELETE  phrase,
            Delete a node and a relationship.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MATCH (n)
            DETACH DELETE n
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.DetachDelete(System.String)">
            <summary>
            Create DETACH DELETE phrase,
            Delete all nodes and relationships from the database.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MATCH (n)
            DETACH DELETE n
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Unwind(System.String,System.String,System.String)">
            <summary>
            Create UNWIND phrase.
            With UNWIND, any list can be transformed back into individual rows.
            The example matches all names from a list of names.
            </summary>
            <param name="collection">The collection.</param>
            <param name="variable">The variable.</param>
            <param name="collectionSign">The collection sign.</param>
            <returns></returns>
            <example><![CDATA[
            Unwind("names", "name")
            Results in:
            UNWIND $names AS name
            -------------------------
            Unwind("names", "name", string.Empty)
            Results in:
            UNWIND names AS name
            -------------------------
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.ForEach(System.String)">
            <summary>
            Compose ForEach phrase
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            FOREACH (r IN relationships(path) | SET r.marked = true)
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.ForEach(System.String,System.String,System.String[])">
            <summary>
            Compose ForEach phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="collection">The collection.</param>
            <param name="propNames">The property names.</param>
            <returns></returns>
            <example><![CDATA[
            ForEach("n", "nations", nameof(Foo.Name), nameof(Bar.Id))
            FOREACH (n IN nations | SET n.Name = $n.Name, n.Id = $n.Id)
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.ForEach(System.String,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Compose ForEach phrase
            </summary>
            <param name="variable">The variable.</param>
            <param name="collection">The collection.</param>
            <param name="propNames">The property names.</param>
            <returns></returns>
            <example><![CDATA[
            ForEach("n", "nations", new [] {nameof(Foo.Name), nameof(Bar.Id)})
            FOREACH (n IN nations | SET n.Name = $n.Name, n.Id = $n.Id)
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.ForEachByConvention``1(System.String,System.String,System.Func{System.String,System.Boolean})">
            <summary>
            Compose ForEach phrase by convention.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="variable">The variable.</param>
            <param name="collection">The collection.</param>
            <param name="filter">The filter.</param>
            <returns></returns>
            <example><![CDATA[
            ForEach("$users", name =&gt; name.EndsWith("Name"))
            ForEach(user IN $users | SET user.FirstName = $user.FirstName, user.LastName = $user.LastName) // Update or create a property.
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.With(System.String)">
            <summary>
            Create WITH  phrase.
            WThe WITH syntax is similar to RETURN.
            It separates query parts explicitly,
            allowing you to declare which variables to carry over to the next part.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            MATCH (user)-[:FRIEND]-(friend)
            WHERE user.name = $name
            WITH user, count(friend) AS friends
            WHERE friends > 10
            RETURN user
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Return(System.String)">
            <summary>
            Create RETURN phrase.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            RETURN * // Return the value of all variables.
            RETURN n AS columnName // Use alias for result column name.
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Return">
            <summary>
            Create RETURN phrase.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Weknow.FluentCypher.Return``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Create RETURN phrase.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            .Return<Foo>(f => f.Name)
            RETURN f.Name
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.ReturnDistinct(System.String)">
            <summary>
            Create RETURN DISTINCT phrase.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            RETURN DISTINCT n // Return unique rows.
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.ReturnDistinct``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Create RETURN DISTINCT phrase.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression">The expression.</param>
            <returns></returns>
            <example><![CDATA[
            .ReturnDistinct<Foo>(f => f.Name)
            RETURN DISTINCT f.Name
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Union">
            <summary>
            Create UNION phrase.
            Returns the distinct union of all query results.
            Result column types and names have to match.
            </summary>
            <returns></returns>
            <example><![CDATA[
            MATCH (a)-[:KNOWS]->(b)
            RETURN b.name
            UNION
            MATCH (a)-[:LOVES]->(b)
            RETURN b.name
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.UnionAll">
            <summary>
            Create UNION ALL phrase.
            Returns the distinct union of all query results.
            Result column types and names have to match.
            Including duplicated rows.
            </summary>
            <returns></returns>
            <example><![CDATA[
            MATCH (a)-[:KNOWS]->(b)
            RETURN b.name
            UNION All
            MATCH (a)-[:LOVES]->(b)
            RETURN b.name
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Call(System.String)">
            <summary>
            Create CALL phrase,
            Delete a node and a relationship.
            </summary>
            <param name="statement">The statement.</param>
            <returns></returns>
            <example><![CDATA[
            CALL db.labels() YIELD label
            This shows a standalone call to the built-in
            procedure db.labels to list all labels used in the database.
            Note that required procedure arguments are given explicitly
            in brackets after the procedure name.
            ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.Composite(System.Func{Weknow.FluentCypher,Weknow.FluentCypher},Weknow.CypherPhrase,System.String,System.String)">
            <summary>
            Adds the fluent cypher.
            </summary>
            <param name="childrenExpression">The delegate expression.</param>
            <param name="phrase">The phrase.</param>
            <param name="openCypher">The open cypher.</param>
            <param name="closeCypher">The close cypher.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.FluentCypher.Composite(Weknow.FluentCypher,Weknow.CypherPhrase,System.String,System.String,System.String,Weknow.FluentCypher[])">
            <summary>
            Adds the fluent cypher.
            </summary>
            <param name="child">The child.</param>
            <param name="phrase">The phrase.</param>
            <param name="openCypher">The open cypher.</param>
            <param name="closeCypher">The close cypher.</param>
            <param name="childrenSeparator">The children separator (space if empty).</param>
            <param name="moreChildren">The more children.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.FluentCypher.Composite(Weknow.FluentCypher,System.String,Weknow.FluentCypher[])">
            <summary>
            Adds the fluent cypher.
            </summary>
            <param name="child">The child.</param>
            <param name="childrenSeparator">The children separator (space if empty).</param>
            <param name="moreChildren">The more children.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.FluentCypher.Composite(System.Collections.Generic.IEnumerable{Weknow.FluentCypher},System.String,Weknow.CypherPhrase,System.String,System.String)">
            <summary>
            Adds the fluent cypher.
            </summary>
            <param name="children">The delegated.</param>
            <param name="childrenSeparator">The children separator (space if empty).</param>
            <param name="phrase">The phrase.</param>
            <param name="openCypher">The open cypher.</param>
            <param name="closeCypher">The close cypher.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.FluentCypher.As(System.String)">
            <summary>
            Create As phrase
            </summary>
            <param name="name">The name.</param>
            <returns></returns>
            <example><![CDATA[
            collect(list) AS items
            /// ]]></example>
        </member>
        <member name="M:Weknow.FluentCypher.AddAmbientLabels(System.String[])">
            <summary>
            Adds the ambient labels.
            additional ambient labels which will be added to cypher queries
            (when the expression is not hard-codded string).
            </summary>
            <param name="labels">The labels.</param>
            <returns></returns>
        </member>
        <member name="P:Weknow.FluentCypher.Entity">
            <summary>
            Node mutation by entity.
            </summary>
        </member>
        <member name="P:Weknow.FluentCypher.Entities">
            <summary>
            Nodes mutation by entities (use Unwind pattern).
            </summary>
        </member>
        <member name="M:Weknow.FluentCypher.ToCypher(Weknow.CypherFormat)">
            <summary>
            Gets the cypher statement.
            </summary>
        </member>
        <member name="M:Weknow.FluentCypher.GenerateCypher(Weknow.CypherFormat)">
            <summary>
            Generates the cypher.
            </summary>
            <param name="cypherFormat">The cypher format.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.FluentCypher.AccumulateForward(System.Text.StringBuilder,Weknow.FluentCypher,Weknow.CypherFormat)">
            <summary>
            Accumulates function for aggregation - used fromGenerateCypher .
            </summary>
            <param name="sb">The sb.</param>
            <param name="current">The current.</param>
            <param name="cypherFormat">The cypher format.</param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">Delegation must be of phrase None</exception>
        </member>
        <member name="M:Weknow.FluentCypher.AccumulateBackward(System.Text.StringBuilder,Weknow.FluentCypher,Weknow.CypherFormat)">
            <summary>
            Accumulates function for aggregation - used fromGenerateCypher .
            </summary>
            <param name="sb">The sb.</param>
            <param name="current">The current.</param>
            <param name="cypherFormat">The cypher format.</param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException">Delegation must be of phrase None</exception>
        </member>
        <member name="M:Weknow.FluentCypher.FormatSingleLine(Weknow.FluentCypher,System.Text.StringBuilder)">
            <summary>
            Formats the single line.
            </summary>
            <param name="current">The current.</param>
            <param name="sb">The sb.</param>
        </member>
        <member name="M:Weknow.FluentCypher.FormatMultiLine(Weknow.FluentCypher,System.Text.StringBuilder)">
            <summary>
            Formats the multi line.
            </summary>
            <param name="current">The current.</param>
            <param name="sb">The sb.</param>
        </member>
        <member name="M:Weknow.FluentCypher.FormatMultiLineDense(Weknow.FluentCypher,System.Text.StringBuilder,System.Int32)">
            <summary>
            Formats the multi line dense.
            </summary>
            <param name="current">The current.</param>
            <param name="sb">The sb.</param>
            <param name="repeat">The repeat.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.FluentCypher.FormatConnectionPhrase(Weknow.FluentCypher,System.Text.StringBuilder)">
            <summary>
            Formats the connection phrase.
            </summary>
            <param name="current">The current.</param>
            <param name="sb"></param>
        </member>
        <member name="M:Weknow.FluentCypher.RepeatCount(Weknow.FluentCypher)">
            <summary>
            Repeats the count.
            </summary>
            <param name="current">The current.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.FluentCypher.op_Implicit(Weknow.FluentCypher)~System.String">
            <summary>
            Performs an implicit conversion from <see cref="T:Weknow.CypherBuilder"/> to <see cref="T:System.String"/>.
            </summary>
            <param name="builder">The builder.</param>
            <returns>
            The result of the conversion.
            </returns>
        </member>
        <member name="M:Weknow.FluentCypher.ToString">
            <summary>
            Converts to string.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Weknow.FluentCypher.ReverseEnumerable">
            <summary>
            Reverses the enumerable.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Weknow.FluentCypher.System#Collections#Generic#IEnumerable{Weknow#FluentCypher}#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            An enumerator that can be used to iterate through the collection.
            </returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Weknow.FluentCypher.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            <returns>
            An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="T:Weknow.Helpers.Helper">
            <summary>
            Fluent cypher builder
            </summary>
            <seealso cref="T:Weknow.FluentCypher" />
        </member>
        <member name="M:Weknow.Helpers.Helper.ExtractLambdaExpression``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
            Extracts the lambda expression.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expression">The exclude.</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException">
            </exception>
        </member>
        <member name="M:Weknow.Helpers.Helper.ExtractLambdaExpressionParameters(System.Linq.Expressions.Expression)">
            <summary>
            Extracts parameters the lambda expression.
            </summary>
            <param name="exclude">The exclude.</param>
            <returns></returns>
            <exception cref="T:System.NotSupportedException"></exception>
        </member>
        <member name="M:Weknow.Helpers.Helper.GetProperties``1">
            <summary>
            Gets the properties names.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Weknow.Helpers.Helper.FormatSetWhere(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String)">
            <summary>
            Formats SET or WHERE phrases.
            </summary>
            <param name="propNames">The property names.</param>
            <param name="variable">The variable.</param>
            <param name="parameterPrefix">The parameter prefix.</param>
            <param name="parameterSign">The parameter sign.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.Helpers.Helper.NewLineSeparatorStrategy(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Separators the strategy.
            </summary>
            <param name="propNames">The property names.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.Helpers.Helper.SetSeparatorStrategy(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Separators the strategy.
            </summary>
            <param name="propNames">The property names.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.Helpers.Helper.FormatStatement(System.Text.StringBuilder,Weknow.FluentCypher,System.Int32)">
            <summary>
            Formats the statement.
            </summary>
            <param name="builder">The sb</param>
            <param name="current">The current.</param>
            <param name="repeat">The repeat.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.Helpers.Helper.FormatByConvention(System.String,Weknow.CypherNamingConvention)">
            <summary>
            Formats by convention.
            </summary>
            <param name="text">The text.</param>
            <param name="convention">The convention.</param>
            <returns></returns>
        </member>
        <member name="M:Weknow.Helpers.Helper.ToParameterConvention(System.String)">
            <summary>
            Convention of formating variable as parameter.
            </summary>
            <param name="variable">The variable.</param>
            <returns></returns>
        </member>
    </members>
</doc>
